{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Retirement Income Toolkit Toolkit of R modules for researchers to use in modeling retirement and age care risks, simulating cash flows for a range of retirement and long-term care products including Australian government support for Age Pensions and Aged Care based on means-testing, pricing and quantifying risk for a range of finance and insurance products to finance retirement and aged care risks. Toolkit Modules Aggregate Mortality Simulation This module will produce future cohort mortality scenarios for a specified age group for input into cash flow simulation and valuation modules. Input will be the model selected and parameter estimates derived from other available R packages (StMoMo). A range of aggregate mortality models will be included so users can select the preferred model: Lee-Carter Age-Period-Cohort Renshaw-Haberman, CBD Gaussian affine (2 and 3-factor models) Output will include: Future cohort mortality rates and survival probability curves at future dates for a specified age cohort (starting from age 50 to age 110) Initial age risk-adjusted survival probabilities using specified risk adjustment methods (with input parameters for risk adjustment) Sharpe ratio Wang transform Price of risk for factor models Distributions of future lifetimes along (with summary statistics including expected future lifetime, standard deviation of future lifetime, impact of uncertainty in mortality rates versus expected mortality rates and survival probabilities) Health State Modeling This module will produce transition probabilities for health state and functional disability models for a specified initial age (from 50 to 65 up to age 110) and health state based on the calibrated parametrization of models. Models to include static models, improvement trends in transition rates and stochastic transition rates (latent factor). Models will include functional disability based on: Various ADL\u2019s (2+, 3+, cognitive decline) with recovery Joint health status Disability states based on core activities for Australian applications Output will include: Probability transition matrices for different starting ages derived from transition rates, with trends Expected transition rates and simulated future transition rates for stochastic simulations Models will be included to forecast the Australian prevalence of disabled populations based on functional disability models. Economic Scenario Generator Outputs are joint simulated scenarios over specified horizons (age 50 to 110 \u2013 60 years) for economic variables, distributions of simulated variables at differing horizons (10 years, 20 years, 50 years, 60 years). The R code will input the parameters for a selected model (VAR) and generate: Simulated (correlated) paths for all the variables to use in cash flow modeling + computing expected values Valuation of cash flows in the cash flow module Distributions of the variables at different horizons \u2013 5 years, 10 years, 30 years Distributions of values of assets in real terms (deflated by GDP, CPI) over different horizons to show the impact of real returns and uncertainty in returns on other assets (equities, cash, housing, rolling bonds). Cash Flow Simulation + Pricing This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products. Retirement products include: Account-based pensions Life annuities Deferred life annuities Pooled annuities Long-term care insurance Care annuities Variable annuities with GMWB Reverse mortgages with NNEG Risk-adjusted expected cash flows are computed, and prices are determined based on specified assumptions. Models use Australian data for Australian applications initially. The module includes government age pension and aged care based on current means-testing.","title":"Home"},{"location":"#retirement-income-toolkit","text":"Toolkit of R modules for researchers to use in modeling retirement and age care risks, simulating cash flows for a range of retirement and long-term care products including Australian government support for Age Pensions and Aged Care based on means-testing, pricing and quantifying risk for a range of finance and insurance products to finance retirement and aged care risks.","title":"Retirement Income Toolkit"},{"location":"#toolkit-modules","text":"","title":"Toolkit Modules"},{"location":"#aggregate-mortality-simulation","text":"This module will produce future cohort mortality scenarios for a specified age group for input into cash flow simulation and valuation modules. Input will be the model selected and parameter estimates derived from other available R packages (StMoMo). A range of aggregate mortality models will be included so users can select the preferred model: Lee-Carter Age-Period-Cohort Renshaw-Haberman, CBD Gaussian affine (2 and 3-factor models) Output will include: Future cohort mortality rates and survival probability curves at future dates for a specified age cohort (starting from age 50 to age 110) Initial age risk-adjusted survival probabilities using specified risk adjustment methods (with input parameters for risk adjustment) Sharpe ratio Wang transform Price of risk for factor models Distributions of future lifetimes along (with summary statistics including expected future lifetime, standard deviation of future lifetime, impact of uncertainty in mortality rates versus expected mortality rates and survival probabilities)","title":"Aggregate Mortality Simulation"},{"location":"#health-state-modeling","text":"This module will produce transition probabilities for health state and functional disability models for a specified initial age (from 50 to 65 up to age 110) and health state based on the calibrated parametrization of models. Models to include static models, improvement trends in transition rates and stochastic transition rates (latent factor). Models will include functional disability based on: Various ADL\u2019s (2+, 3+, cognitive decline) with recovery Joint health status Disability states based on core activities for Australian applications Output will include: Probability transition matrices for different starting ages derived from transition rates, with trends Expected transition rates and simulated future transition rates for stochastic simulations Models will be included to forecast the Australian prevalence of disabled populations based on functional disability models.","title":"Health State Modeling"},{"location":"#economic-scenario-generator","text":"Outputs are joint simulated scenarios over specified horizons (age 50 to 110 \u2013 60 years) for economic variables, distributions of simulated variables at differing horizons (10 years, 20 years, 50 years, 60 years). The R code will input the parameters for a selected model (VAR) and generate: Simulated (correlated) paths for all the variables to use in cash flow modeling + computing expected values Valuation of cash flows in the cash flow module Distributions of the variables at different horizons \u2013 5 years, 10 years, 30 years Distributions of values of assets in real terms (deflated by GDP, CPI) over different horizons to show the impact of real returns and uncertainty in returns on other assets (equities, cash, housing, rolling bonds).","title":"Economic Scenario Generator"},{"location":"#cash-flow-simulation-pricing","text":"This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products. Retirement products include: Account-based pensions Life annuities Deferred life annuities Pooled annuities Long-term care insurance Care annuities Variable annuities with GMWB Reverse mortgages with NNEG Risk-adjusted expected cash flows are computed, and prices are determined based on specified assumptions. Models use Australian data for Australian applications initially. The module includes government age pension and aged care based on current means-testing.","title":"Cash Flow Simulation + Pricing"},{"location":"Aggregate%20Mortality/overview/","text":"Overview There is a popular package in R, StMoMo, that is used for stochastic mortality modelling. It includes functions that fit a wide range of age-period-cohort models such as the Lee-Carter, Cairns-Blake-Dowd models and many others. These are typically used to forecast and simulate future mortality rates. The aggregate mortality module extends upon the StMoMo package by introducing the following functionalities: Adding methods for more accurate mortality estimation at older ages (rate completion) Transforming survival functions from the real world to the risk-free probability measure Distribution and quantile functions of a survival function Simulation plots of the survival function and expected curtate future lifetime for a cohort These functions will allow for more accurate mortality studies at older ages (90+) and the pricing of a diverse range of insurance products. This module should be used in tandem with the StMoMo package. Namely, the inputs of this module will usually be the mortality rates outputted by the StMoMo package. A general overview of the module and the sequence of function executions can be visualised by the flowchart below:","title":"Overview"},{"location":"Aggregate%20Mortality/overview/#overview","text":"There is a popular package in R, StMoMo, that is used for stochastic mortality modelling. It includes functions that fit a wide range of age-period-cohort models such as the Lee-Carter, Cairns-Blake-Dowd models and many others. These are typically used to forecast and simulate future mortality rates. The aggregate mortality module extends upon the StMoMo package by introducing the following functionalities: Adding methods for more accurate mortality estimation at older ages (rate completion) Transforming survival functions from the real world to the risk-free probability measure Distribution and quantile functions of a survival function Simulation plots of the survival function and expected curtate future lifetime for a cohort These functions will allow for more accurate mortality studies at older ages (90+) and the pricing of a diverse range of insurance products. This module should be used in tandem with the StMoMo package. Namely, the inputs of this module will usually be the mortality rates outputted by the StMoMo package. A general overview of the module and the sequence of function executions can be visualised by the flowchart below:","title":"Overview"},{"location":"Aggregate%20Mortality/period_cohort/","text":"Period and Cohort Rates Mortality rates are often presented in a period format where each column represents the mortality rates across ages for a particular calendar year. However, they can also be expressed in a cohort format where each column is for a particular cohort. Cohort rates are more suitable for the pricing of insurance products, so this module introduces two helper functions to convert between period and cohort mortality rates and one-year death probabilities. Period to Cohort Rates period2cohort(period_rates, ages, init_age = NULL) Parameters: period_rates : matrix/array period mortality rates with age rows, calendar year columns (and simulation number 3rd dimension) ages : vector vector of ages for period_rates init_age : numeric initial age of cohort (default smallest age) Returns: matrix/array of cohort mortality rates with age rows, cohort columns (and simulation number 3rd dimension). The columns represent the cohort aged init_age in the corresponding year. Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' period_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 # convert to rates for cohort aged 55 cohort_rates_55 <- period2cohort ( period_rates , ages , init_age = 55 ) Note The conversions between period and cohort mortality rates will only return the upper triangle. Cohort to Period Rates cohort2period(cohort_rates) Parameters: cohort_rates : matrix/array cohort mortality rates with age rows, cohort columns (and simulation number 3rd dimension) Returns: matrix/array of period mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the Kannisto completion method on male mortality rates # from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) # suppose these are rates for cohort starting at age 60 cohort_rates_60 <- completed_rates [ as.character ( 60 : 130 ), ] period_rates <- cohort2period ( cohort_rates_60 ) Note The conversions between period and cohort mortality rates will only return the upper triangle.","title":"Period and Cohort Rates"},{"location":"Aggregate%20Mortality/period_cohort/#period-and-cohort-rates","text":"Mortality rates are often presented in a period format where each column represents the mortality rates across ages for a particular calendar year. However, they can also be expressed in a cohort format where each column is for a particular cohort. Cohort rates are more suitable for the pricing of insurance products, so this module introduces two helper functions to convert between period and cohort mortality rates and one-year death probabilities.","title":"Period and Cohort Rates"},{"location":"Aggregate%20Mortality/period_cohort/#period-to-cohort-rates","text":"period2cohort(period_rates, ages, init_age = NULL) Parameters: period_rates : matrix/array period mortality rates with age rows, calendar year columns (and simulation number 3rd dimension) ages : vector vector of ages for period_rates init_age : numeric initial age of cohort (default smallest age) Returns: matrix/array of cohort mortality rates with age rows, cohort columns (and simulation number 3rd dimension). The columns represent the cohort aged init_age in the corresponding year. Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' period_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 # convert to rates for cohort aged 55 cohort_rates_55 <- period2cohort ( period_rates , ages , init_age = 55 ) Note The conversions between period and cohort mortality rates will only return the upper triangle.","title":"Period to Cohort Rates"},{"location":"Aggregate%20Mortality/period_cohort/#cohort-to-period-rates","text":"cohort2period(cohort_rates) Parameters: cohort_rates : matrix/array cohort mortality rates with age rows, cohort columns (and simulation number 3rd dimension) Returns: matrix/array of period mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the Kannisto completion method on male mortality rates # from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) # suppose these are rates for cohort starting at age 60 cohort_rates_60 <- completed_rates [ as.character ( 60 : 130 ), ] period_rates <- cohort2period ( cohort_rates_60 ) Note The conversions between period and cohort mortality rates will only return the upper triangle.","title":"Cohort to Period Rates"},{"location":"Aggregate%20Mortality/rate_change/","text":"Mortality Rate Changing Mortality rates can be expressed in different types, such as central death rates, 1-year death probabilities and force of mortality. Different mortality rate completion methods require different types of mortality rates so this module includes a helper function to change between the types of mortality rates. This module uses the following notation for an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\) : \\(m_{x, y}^{(i)}\\) : central death rate \\(q_{x, y}^{(i)}\\) : 1-year death probability \\(\\mu_{x, y}^{(i)}\\) : force of mortality Implementation assumes a constant force of mortality for fractional ages, resulting in the following conversions: \\(q_{x, y}^{(i)} = 1 - e^{-\\mu_{x, y}^{(i)}}\\) \\(\\mu_{x, y}^{(i)} = m_{x, y}^{(i)}\\) \\(m_{x, y}^{(i)} = -\\log(1 - q_{x, y}^{(i)})\\) Mortality Rate Changing rate2rate(rates, from, to) Parameters: rates : matrix/array mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) from : character input type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality to : character desired output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality Returns: matrix/array of converted mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' central_rates <- mortality_AUS_data $ rate $ male # convert to 1-yr death probabilities death_prob <- rate2rate ( central_rates , from = \"central\" , to = \"prob\" )","title":"Mortality Rate Changing"},{"location":"Aggregate%20Mortality/rate_change/#mortality-rate-changing","text":"Mortality rates can be expressed in different types, such as central death rates, 1-year death probabilities and force of mortality. Different mortality rate completion methods require different types of mortality rates so this module includes a helper function to change between the types of mortality rates. This module uses the following notation for an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\) : \\(m_{x, y}^{(i)}\\) : central death rate \\(q_{x, y}^{(i)}\\) : 1-year death probability \\(\\mu_{x, y}^{(i)}\\) : force of mortality Implementation assumes a constant force of mortality for fractional ages, resulting in the following conversions: \\(q_{x, y}^{(i)} = 1 - e^{-\\mu_{x, y}^{(i)}}\\) \\(\\mu_{x, y}^{(i)} = m_{x, y}^{(i)}\\) \\(m_{x, y}^{(i)} = -\\log(1 - q_{x, y}^{(i)})\\)","title":"Mortality Rate Changing"},{"location":"Aggregate%20Mortality/rate_change/#mortality-rate-changing_1","text":"rate2rate(rates, from, to) Parameters: rates : matrix/array mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) from : character input type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality to : character desired output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality Returns: matrix/array of converted mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' central_rates <- mortality_AUS_data $ rate $ male # convert to 1-yr death probabilities death_prob <- rate2rate ( central_rates , from = \"central\" , to = \"prob\" )","title":"Mortality Rate Changing"},{"location":"Aggregate%20Mortality/rate_completion/","text":"Mortality Rate Completion Mortality rates observed at old ages are affected by random fluctuations and hence, unreliable. To accommodate for this, different completion methods have been proposed to 'extrapolate' more accurate mortality rates at older ages, and are implemented in this module. Wrapper Function The different completion methods can be incorporated into a wrapper function which implements the chosen completion method. complete_old_age(rates, ages, old_ages, method = \"kannisto\", type = 'prob', closure_age = 130, years = NULL, ...) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for method : character the completion method to be used. 'CK' for Coale-Kisker, 'DG' for Denuit and Goderniaux 'Kannisto' for Kannisto type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age years : vector optional numeric vector of years for rates ... additional arguments required for the chosen completion method Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # first convert mortality rates to death probabilities AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) # completing mortality rates for old ages DG_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"DG\" , type = \"prob\" ) CK_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"CK\" , type = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) Coale and Kisker Method The model proposed by Coale and Kisker (1990) is one of techniques used to complete mortality rates for old ages. The implementation follows Pitacco et al. (2009) and is based on the exponential age-specific rate of change of central death rates $$ k_{x, y}^{(i)} = \\log \\left( \\frac{m_{x, y}^{(i)}}{m_{x - 1, y}^{(i)}} \\right) . $$ The model assumes that \\(k_{x, y}^{(i)}\\) is linear over some age \\(x = \\beta\\) , so $$ k_{x, y}^{(i)} = k_{\\beta, y}^{(i)} - (x - \\beta) s_y^{(i)} $$ where \\(s_y^{(i)}\\) can be calculated assuming that \\(k_{\\beta, y}^{(i)}\\) is calculated from empirical data. The central death rate can then be calculated for ages over \\(\\beta\\) by using $$ m_{x, y}^{(i)} = m_{\\beta, y}^{(i)} \\exp \\left( \\sum^x_{l = \\beta + 1} k_{l, y}^{(i)} \\right). $$ In the implementation, \\(\\beta + 1\\) is taken to be the smallest value in old_ages . coale_kisker(rates, ages, old_ages, type = 'central', closure_age = 130, m_end = 1, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for. Must connect with ages , see details type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age m_end : numeric/vector central death rate at maximum age years : vector optional numeric vector of years for rates Details: 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect closure_age must be equal to the last age in old_ages Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 completed_rates <- coale_kisker ( AUS_male_rates , ages , old_ages , type = \"central\" ) References: Coale, Ansley J. and Kisker, Ellen E. 1990 'Defects in data on old-age mortality in the United States: New procedures for calculating schedules and life tables at the higher ages,' Asian and Pacific Population Forum , 4: 1-31 Pitacco, Ermanno & Denuit, Michel & Haberman, Steven & Olivieri, Annamaria. (2009). Modelling Longevity Dynamics for Pensions and Annuity Business. Denuit & Goderniaux Method The Denuit and Goderniaux method (Denuit & Goderniaux, 2005) is a life table closing procedure based on a constrained log-quadratic regression of the form $$ \\log(q_{x, y}^{(i)}) = a_y^{(i)} + b_y^{(i)} x + c_y^{(i)} x^2 + \\epsilon_{x,y}^{(i)} $$ where \\(\\epsilon_{x,y}^{(i)}\\) i.i.d \\(N(0, \\sigma^2)\\) . This is fitted on ages start_fit_age and over for each year. A closure constraint (max age), generally set at 130 is imposed as well as an inflexion constraint that makes the rate of mortality increase at older ages slow down. Smoothing can also be applied to the results using a simple geometric average on the estimates. denuit_goderniaux(rates, ages, old_ages, type = 'prob', closure_age = 130, start_fit_age = 75, smoothing = FALSE, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for. Must connect with ages , see details type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age start_fit_age : numeric model is fitted to ages starting from this age smoothing : logical set TRUE to apply smoothing to the completed rates years : vector optional numeric vector of years for rates Details: 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect closure_age must be equal to the last age in old_ages Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # first convert mortality rates to death probabilties AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) completed_qx <- denuit_goderniaux ( AUS_male_qx , ages , old_ages , type = \"prob\" ) # fit on ages 80:110 instead completed_qx_from_80 <- denuit_goderniaux ( AUS_male_qx , ages , old_ages , type = \"prob\" , start_fit_age = 80 ) References: Denuit, M. and Goderniaux A., 2005 'Closing and Projecting lifetables using log-linear models', Bulletin of the Swiss Association of Actuaries p. 29-49 Kannisto Method The Kannisto model proposed by Kannisto (1994) is based on the logistic model to close mortality rates for old ages. A model of the form $$ \\text{logit}(\\mu_{x, y}^{(i)}) = \\log(a_{y}^{(i)}) + b_{y}^{(i)} x $$ is fitted on a set of fitted ages to obtain \\(a_{y}^{(i)}\\) and \\(b_{y}^{(i)}\\) . The force of mortality for older ages can then be extrapolated via $$ \\mu_{x, y}^{(i)} = \\frac{a_{y}^{(i)} \\exp \\left({b_{y}^{(i)}} \\right)} {1 + a_{y}^{(i)} \\exp \\left({b_{y}^{(i)}} \\right)} $$ The set of fitted ages tends to be near the tail end of ages where the mortality rates are more accurate. kannisto(rates, ages, old_ages, fitted_ages, type = 'force', closure_age = 130, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for. Must connect with ages , see details. fitted_ages : vector vector of ages to fit initial model. Must connect with old_ages , see details. type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age years : vector optional numeric vector of years for rates Details: 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect closure_age must be equal to the last age in old_ages Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # fit model on tail end of ages where mortality is still accurate fitted_ages <- 76 : 90 completed_rates <- kannisto ( AUS_male_rates , ages , old_ages , fitted_ages , type = \"central\" ) References: Kannisto, V. (1994). Development of oldest-old mortality, 1950-1990: Evidence from 28 devel- oped countries. Odense University Press. Antonio, Katrien, et al. The IA|BE 2020 Mortality Projection for the Belgian Population. 2020.","title":"Mortality Rate Completion"},{"location":"Aggregate%20Mortality/rate_completion/#mortality-rate-completion","text":"Mortality rates observed at old ages are affected by random fluctuations and hence, unreliable. To accommodate for this, different completion methods have been proposed to 'extrapolate' more accurate mortality rates at older ages, and are implemented in this module.","title":"Mortality Rate Completion"},{"location":"Aggregate%20Mortality/rate_completion/#wrapper-function","text":"The different completion methods can be incorporated into a wrapper function which implements the chosen completion method. complete_old_age(rates, ages, old_ages, method = \"kannisto\", type = 'prob', closure_age = 130, years = NULL, ...) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for method : character the completion method to be used. 'CK' for Coale-Kisker, 'DG' for Denuit and Goderniaux 'Kannisto' for Kannisto type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age years : vector optional numeric vector of years for rates ... additional arguments required for the chosen completion method Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # first convert mortality rates to death probabilities AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) # completing mortality rates for old ages DG_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"DG\" , type = \"prob\" ) CK_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"CK\" , type = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 )","title":"Wrapper Function"},{"location":"Aggregate%20Mortality/rate_completion/#coale-and-kisker-method","text":"The model proposed by Coale and Kisker (1990) is one of techniques used to complete mortality rates for old ages. The implementation follows Pitacco et al. (2009) and is based on the exponential age-specific rate of change of central death rates $$ k_{x, y}^{(i)} = \\log \\left( \\frac{m_{x, y}^{(i)}}{m_{x - 1, y}^{(i)}} \\right) . $$ The model assumes that \\(k_{x, y}^{(i)}\\) is linear over some age \\(x = \\beta\\) , so $$ k_{x, y}^{(i)} = k_{\\beta, y}^{(i)} - (x - \\beta) s_y^{(i)} $$ where \\(s_y^{(i)}\\) can be calculated assuming that \\(k_{\\beta, y}^{(i)}\\) is calculated from empirical data. The central death rate can then be calculated for ages over \\(\\beta\\) by using $$ m_{x, y}^{(i)} = m_{\\beta, y}^{(i)} \\exp \\left( \\sum^x_{l = \\beta + 1} k_{l, y}^{(i)} \\right). $$ In the implementation, \\(\\beta + 1\\) is taken to be the smallest value in old_ages . coale_kisker(rates, ages, old_ages, type = 'central', closure_age = 130, m_end = 1, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for. Must connect with ages , see details type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age m_end : numeric/vector central death rate at maximum age years : vector optional numeric vector of years for rates Details: 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect closure_age must be equal to the last age in old_ages Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 completed_rates <- coale_kisker ( AUS_male_rates , ages , old_ages , type = \"central\" ) References: Coale, Ansley J. and Kisker, Ellen E. 1990 'Defects in data on old-age mortality in the United States: New procedures for calculating schedules and life tables at the higher ages,' Asian and Pacific Population Forum , 4: 1-31 Pitacco, Ermanno & Denuit, Michel & Haberman, Steven & Olivieri, Annamaria. (2009). Modelling Longevity Dynamics for Pensions and Annuity Business.","title":"Coale and Kisker Method"},{"location":"Aggregate%20Mortality/rate_completion/#denuit-goderniaux-method","text":"The Denuit and Goderniaux method (Denuit & Goderniaux, 2005) is a life table closing procedure based on a constrained log-quadratic regression of the form $$ \\log(q_{x, y}^{(i)}) = a_y^{(i)} + b_y^{(i)} x + c_y^{(i)} x^2 + \\epsilon_{x,y}^{(i)} $$ where \\(\\epsilon_{x,y}^{(i)}\\) i.i.d \\(N(0, \\sigma^2)\\) . This is fitted on ages start_fit_age and over for each year. A closure constraint (max age), generally set at 130 is imposed as well as an inflexion constraint that makes the rate of mortality increase at older ages slow down. Smoothing can also be applied to the results using a simple geometric average on the estimates. denuit_goderniaux(rates, ages, old_ages, type = 'prob', closure_age = 130, start_fit_age = 75, smoothing = FALSE, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for. Must connect with ages , see details type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age start_fit_age : numeric model is fitted to ages starting from this age smoothing : logical set TRUE to apply smoothing to the completed rates years : vector optional numeric vector of years for rates Details: 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect closure_age must be equal to the last age in old_ages Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # first convert mortality rates to death probabilties AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) completed_qx <- denuit_goderniaux ( AUS_male_qx , ages , old_ages , type = \"prob\" ) # fit on ages 80:110 instead completed_qx_from_80 <- denuit_goderniaux ( AUS_male_qx , ages , old_ages , type = \"prob\" , start_fit_age = 80 ) References: Denuit, M. and Goderniaux A., 2005 'Closing and Projecting lifetables using log-linear models', Bulletin of the Swiss Association of Actuaries p. 29-49","title":"Denuit &amp; Goderniaux Method"},{"location":"Aggregate%20Mortality/rate_completion/#kannisto-method","text":"The Kannisto model proposed by Kannisto (1994) is based on the logistic model to close mortality rates for old ages. A model of the form $$ \\text{logit}(\\mu_{x, y}^{(i)}) = \\log(a_{y}^{(i)}) + b_{y}^{(i)} x $$ is fitted on a set of fitted ages to obtain \\(a_{y}^{(i)}\\) and \\(b_{y}^{(i)}\\) . The force of mortality for older ages can then be extrapolated via $$ \\mu_{x, y}^{(i)} = \\frac{a_{y}^{(i)} \\exp \\left({b_{y}^{(i)}} \\right)} {1 + a_{y}^{(i)} \\exp \\left({b_{y}^{(i)}} \\right)} $$ The set of fitted ages tends to be near the tail end of ages where the mortality rates are more accurate. kannisto(rates, ages, old_ages, fitted_ages, type = 'force', closure_age = 130, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for. Must connect with ages , see details. fitted_ages : vector vector of ages to fit initial model. Must connect with old_ages , see details. type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age years : vector optional numeric vector of years for rates Details: 0:110 and 91:130 connect, 0:110 and 111:130 connect, 0:110 and 120:130 do not connect closure_age must be equal to the last age in old_ages Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # fit model on tail end of ages where mortality is still accurate fitted_ages <- 76 : 90 completed_rates <- kannisto ( AUS_male_rates , ages , old_ages , fitted_ages , type = \"central\" ) References: Kannisto, V. (1994). Development of oldest-old mortality, 1950-1990: Evidence from 28 devel- oped countries. Odense University Press. Antonio, Katrien, et al. The IA|BE 2020 Mortality Projection for the Belgian Population. 2020.","title":"Kannisto Method"},{"location":"Aggregate%20Mortality/rate_survival/","text":"Mortality Rate and Survival Function So far, this module has looked at the force of mortality, central death rate and one-year death probability. These are all relevant over a one-year period to determine the probability an individual currently aged \\(x\\) will survive to age \\(x+1\\) . Sometimes it might be of interest to look at the probability an individual survives for more than one year. Hence, this module uses \\(S_{x, y}^{(i)} (t)\\) to denote the probability an individual aged \\(x\\) in calendar/cohort year \\(y\\) will survive to age \\(x + t\\) for simulation \\(i\\) , where \\(t \\geq 0\\) . This survival probability can be calculated for a range of values of \\(t\\) , giving rise to the idea of a survival function. Mortality rates can be converted to survival probabilities by using the formula \\[ S_{x, y}^{(i)} (t) = \\begin{cases} 1 & t = 0 \\\\ \\prod_{l=0}^{t-1} p_{x+l, y}^{(i)} & t > 0 \\end{cases} \\] where \\(p_{x, y}^{(i)} = 1 - q_{x, y}^{(i)}\\) is the one-year survival probability. The conversions between mortality rates and survival probabilities are covered by two helper functions, one for each direction. Mortality Rate to Survival Function rate2survival(rates, ages, from = 'prob', init_age = NULL, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) ages : vector vector of ages for rates from : character type of rate to be converted from: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality init_age : numeric initial age for survival function to be calculated at (default smallest age) years : vector optional numeric vector of years for rates Returns: matrix/array of associated survival function with survival time rows, cohort/year columns (and simulation number 3rd dimension) Usage: # consider the Kannisto completion method on male mortality rates # from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) # compute survival function of an individual aged 55 all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) Survival Function to Mortality Rate survival2rate(surv, ages, to = 'prob', years = NULL) Parameters: surv : matrix/array survival function with survival time rows, cohort/year columns (and simulation number 3rd dimension) ages : vector vector of desired ages for the resulting mortality rates to : character type of rate to be converted to: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality years : vector optional numeric vector of years for surv Returns: matrix/array of associated mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # convert from P to Q measure survival function # see the section on risk neutral probability surv_func_Q <- survivalP2Q ( surv_func , method = \"wang\" , lambda = 1.5 ) # convert from survival function to mortality rates central_rates_Q <- survival2rate ( surv_func_Q , 55 : 130 , to = 'central' )","title":"Mortality Rate and Survival Function"},{"location":"Aggregate%20Mortality/rate_survival/#mortality-rate-and-survival-function","text":"So far, this module has looked at the force of mortality, central death rate and one-year death probability. These are all relevant over a one-year period to determine the probability an individual currently aged \\(x\\) will survive to age \\(x+1\\) . Sometimes it might be of interest to look at the probability an individual survives for more than one year. Hence, this module uses \\(S_{x, y}^{(i)} (t)\\) to denote the probability an individual aged \\(x\\) in calendar/cohort year \\(y\\) will survive to age \\(x + t\\) for simulation \\(i\\) , where \\(t \\geq 0\\) . This survival probability can be calculated for a range of values of \\(t\\) , giving rise to the idea of a survival function. Mortality rates can be converted to survival probabilities by using the formula \\[ S_{x, y}^{(i)} (t) = \\begin{cases} 1 & t = 0 \\\\ \\prod_{l=0}^{t-1} p_{x+l, y}^{(i)} & t > 0 \\end{cases} \\] where \\(p_{x, y}^{(i)} = 1 - q_{x, y}^{(i)}\\) is the one-year survival probability. The conversions between mortality rates and survival probabilities are covered by two helper functions, one for each direction.","title":"Mortality Rate and Survival Function"},{"location":"Aggregate%20Mortality/rate_survival/#mortality-rate-to-survival-function","text":"rate2survival(rates, ages, from = 'prob', init_age = NULL, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) ages : vector vector of ages for rates from : character type of rate to be converted from: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality init_age : numeric initial age for survival function to be calculated at (default smallest age) years : vector optional numeric vector of years for rates Returns: matrix/array of associated survival function with survival time rows, cohort/year columns (and simulation number 3rd dimension) Usage: # consider the Kannisto completion method on male mortality rates # from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) # compute survival function of an individual aged 55 all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 )","title":"Mortality Rate to Survival Function"},{"location":"Aggregate%20Mortality/rate_survival/#survival-function-to-mortality-rate","text":"survival2rate(surv, ages, to = 'prob', years = NULL) Parameters: surv : matrix/array survival function with survival time rows, cohort/year columns (and simulation number 3rd dimension) ages : vector vector of desired ages for the resulting mortality rates to : character type of rate to be converted to: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality years : vector optional numeric vector of years for surv Returns: matrix/array of associated mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # convert from P to Q measure survival function # see the section on risk neutral probability surv_func_Q <- survivalP2Q ( surv_func , method = \"wang\" , lambda = 1.5 ) # convert from survival function to mortality rates central_rates_Q <- survival2rate ( surv_func_Q , 55 : 130 , to = 'central' )","title":"Survival Function to Mortality Rate"},{"location":"Aggregate%20Mortality/risk_neutral/","text":"Risk Neutral Probability Real world survival probabilities are very useful for mortality studies. However, they do not account for longevity risk - the financial risk that people live longer than expected and are thus not suitable for the pricing of insurance products. Hence, this module includes a function that transforms the real world (P world) survival function to a risk neutral (Q world) survival function according to a risk-neutral principle following Tang & Li (2021). To introduce the transformation methods used by this function, the following simplified notation is used: \\(f^P(t)\\) or \\(f^Q(t)\\) : probability density function (pdf) \\(F^P(t)\\) or \\(F^Q(t)\\) : cumulative distribution function (cdf) \\(S^P(t)\\) or \\(S^Q(t)\\) : survival function where \\(S^P(t) = 1 - F^P(t)\\) and \\(S^Q(t) = 1 - F^Q(t)\\) . Note that these functions are applied on an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\) . The first set of transformations are survival function distortions and are as follows: Wang transform: \\(S^Q(t) = 1 - \\Phi(\\Phi^{-1}(1 - S^P(t)) - \\lambda) \\quad (\\lambda \\geq 0)\\) where \\(\\Phi(x)\\) represents the cdf of a standard Gaussian distribution. Proportional hazard transform: \\(S^Q(t) = (S^P(t))^{\\frac{1}{\\lambda}} \\quad (\\lambda \\geq 1)\\) Dual-power transform: \\(S^Q(t) = 1 - \\left(1 - S^P(t)\\right)^\\lambda \\quad (\\lambda \\geq 1)\\) Gini principle: \\(S^Q(t) = (1 + \\lambda)S^P(t) - \\lambda(S^P(t))^2 \\quad (0 \\leq \\lambda \\leq 1)\\) Denneberg's absolute deviation principle: \\(S^Q(t) = \\begin{cases} (1 + \\lambda)S^P(t), & 0 \\leq S^P(t) < 0.5 \\\\ \\lambda + (1 - \\lambda)S^P(t), & 0.5 \\leq S^P(t) \\leq 1 \\end{cases} \\quad (0 \\leq \\lambda \\leq 1)\\) Exponential transform: \\(S^Q(t) = \\frac{1 - e^{-\\lambda S^P(t)}}{1 - e^{-\\lambda}} \\quad (\\lambda > 0)\\) Logarithmic transform: \\(S^Q(t) = \\frac{\\log(1 + \\lambda S^P(t))}{\\log(1 + \\lambda)} \\quad (\\lambda > 0)\\) The remaining transformations are pdf distortions and are given by: Canonical valuation: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)} \\quad (\\lambda > 0)\\) Esscher transform: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\mathbb{E}[e^{\\lambda t}]} = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)} \\quad (\\lambda > 0)\\) We note that for the pdf distortions (univariate canonical valuation and esscher transforms), the risk-adjusted pdfs are identical. Survival Function Risk-Neutral Transformation survivalP2Q(StP, method, lambda) Parameters: StP : matrix/array survival function under P-measure with survival time rows, cohort/year columns (and simulation number 3rd dimension) method : character the distortion risk measure to be used, see details for more information lambda : numeric parameter associated with the distortion risk measure Details: \"wang\": Wang Transform \\((\\lambda \\geq 0)\\) \"ph\": Proportional Hazard Transform \\((\\lambda \\geq 1)\\) \"dp\": Dual-power Transform \\((\\lambda \\geq 1)\\) \"gp\": Gini Principle \\((0 \\leq \\lambda \\leq 1)\\) \"dadp\": Denneberg's Absolute Deviation Principle \\((0 \\leq \\lambda \\leq 1)\\) \"exp\": Exponential Transform \\((\\lambda > 0)\\) \"log\": Logarithmic Transform \\((\\lambda > 0)\\) \"canon\": Univariate Canonical Valuation \\((\\lambda > 0)\\) \"esscher\": Esscher Transform \\((\\lambda > 0)\\) Returns: matrix/array of risk neutral survival function under specified Q-measure with survival time rows, cohort/year columns (and simulation number 3rd dimension) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # convert from P to Q measure survival function surv_func_Q <- survivalP2Q ( surv_func , method = \"wang\" , lambda = 1.5 ) References: Sixian Tang & Jackie Li (2021) Market pricing of longevity-linked securities, Scandinavian Actuarial Journal, 2021:5, 408-436, DOI: 10.1080/03461238.2020.1852105","title":"Risk Neutral Probability"},{"location":"Aggregate%20Mortality/risk_neutral/#risk-neutral-probability","text":"Real world survival probabilities are very useful for mortality studies. However, they do not account for longevity risk - the financial risk that people live longer than expected and are thus not suitable for the pricing of insurance products. Hence, this module includes a function that transforms the real world (P world) survival function to a risk neutral (Q world) survival function according to a risk-neutral principle following Tang & Li (2021). To introduce the transformation methods used by this function, the following simplified notation is used: \\(f^P(t)\\) or \\(f^Q(t)\\) : probability density function (pdf) \\(F^P(t)\\) or \\(F^Q(t)\\) : cumulative distribution function (cdf) \\(S^P(t)\\) or \\(S^Q(t)\\) : survival function where \\(S^P(t) = 1 - F^P(t)\\) and \\(S^Q(t) = 1 - F^Q(t)\\) . Note that these functions are applied on an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\) . The first set of transformations are survival function distortions and are as follows: Wang transform: \\(S^Q(t) = 1 - \\Phi(\\Phi^{-1}(1 - S^P(t)) - \\lambda) \\quad (\\lambda \\geq 0)\\) where \\(\\Phi(x)\\) represents the cdf of a standard Gaussian distribution. Proportional hazard transform: \\(S^Q(t) = (S^P(t))^{\\frac{1}{\\lambda}} \\quad (\\lambda \\geq 1)\\) Dual-power transform: \\(S^Q(t) = 1 - \\left(1 - S^P(t)\\right)^\\lambda \\quad (\\lambda \\geq 1)\\) Gini principle: \\(S^Q(t) = (1 + \\lambda)S^P(t) - \\lambda(S^P(t))^2 \\quad (0 \\leq \\lambda \\leq 1)\\) Denneberg's absolute deviation principle: \\(S^Q(t) = \\begin{cases} (1 + \\lambda)S^P(t), & 0 \\leq S^P(t) < 0.5 \\\\ \\lambda + (1 - \\lambda)S^P(t), & 0.5 \\leq S^P(t) \\leq 1 \\end{cases} \\quad (0 \\leq \\lambda \\leq 1)\\) Exponential transform: \\(S^Q(t) = \\frac{1 - e^{-\\lambda S^P(t)}}{1 - e^{-\\lambda}} \\quad (\\lambda > 0)\\) Logarithmic transform: \\(S^Q(t) = \\frac{\\log(1 + \\lambda S^P(t))}{\\log(1 + \\lambda)} \\quad (\\lambda > 0)\\) The remaining transformations are pdf distortions and are given by: Canonical valuation: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)} \\quad (\\lambda > 0)\\) Esscher transform: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\mathbb{E}[e^{\\lambda t}]} = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)} \\quad (\\lambda > 0)\\) We note that for the pdf distortions (univariate canonical valuation and esscher transforms), the risk-adjusted pdfs are identical.","title":"Risk Neutral Probability"},{"location":"Aggregate%20Mortality/risk_neutral/#survival-function-risk-neutral-transformation","text":"survivalP2Q(StP, method, lambda) Parameters: StP : matrix/array survival function under P-measure with survival time rows, cohort/year columns (and simulation number 3rd dimension) method : character the distortion risk measure to be used, see details for more information lambda : numeric parameter associated with the distortion risk measure Details: \"wang\": Wang Transform \\((\\lambda \\geq 0)\\) \"ph\": Proportional Hazard Transform \\((\\lambda \\geq 1)\\) \"dp\": Dual-power Transform \\((\\lambda \\geq 1)\\) \"gp\": Gini Principle \\((0 \\leq \\lambda \\leq 1)\\) \"dadp\": Denneberg's Absolute Deviation Principle \\((0 \\leq \\lambda \\leq 1)\\) \"exp\": Exponential Transform \\((\\lambda > 0)\\) \"log\": Logarithmic Transform \\((\\lambda > 0)\\) \"canon\": Univariate Canonical Valuation \\((\\lambda > 0)\\) \"esscher\": Esscher Transform \\((\\lambda > 0)\\) Returns: matrix/array of risk neutral survival function under specified Q-measure with survival time rows, cohort/year columns (and simulation number 3rd dimension) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # convert from P to Q measure survival function surv_func_Q <- survivalP2Q ( surv_func , method = \"wang\" , lambda = 1.5 ) References: Sixian Tang & Jackie Li (2021) Market pricing of longevity-linked securities, Scandinavian Actuarial Journal, 2021:5, 408-436, DOI: 10.1080/03461238.2020.1852105","title":"Survival Function Risk-Neutral Transformation"},{"location":"Aggregate%20Mortality/simulation/","text":"Simulating Life Paths One-year death probabilities derived from previous sections can also be used to simulate life paths for a single individual or a particular cohort. Each individual or cohort will be alive at a specified initial age, and deaths are sampled according to the one-year death probabilities given at each age. When simulating for an individual, the function keeps track of their dead or alive status at each age. When simulating for a cohort, the number of people still alive at each age is recorded. Simulate Individual Life Path sim_indiv_path(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, n_sim = 10000, seed = NULL) Parameters: init_age : numeric integer denoting initial age of individual sex : character character denoting the gender of individual, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for an individual starting at init_age in 2022 closure_age : numeric maximum age n_sim : numeric integer denoting number of path simulations seed : numeric integer to be used as the seed for simulation Returns: a matrix where each row is a different path of the individual's dead (-1) or alive (0) status across the years An example looks like: \\[\\begin{pmatrix} 0 & -1 & -1 & -1 & \\ldots & -1 \\\\ 0 & 0 & 0 & -1 & \\ldots & -1 \\\\ & & \\vdots & & & \\\\ 0 & 0 & 0 & 0 & \\ldots & -1 \\\\ 0 & 0 & -1 & -1 & \\ldots & -1 \\end{pmatrix}\\] Note that the first column of the matrix will always be 0 as everyone is alive at the initial age, and the last column will always be -1, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate life paths for females starting at age 60 sim_indiv_path ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_indiv_path ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 ) Simulate Cohort Life Path sim_cohort_path_realised(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000, n_sim = 10000, seed = NULL) Parameters: init_age : numeric integer denoting initial age of cohort sex : character character denoting the gender of cohort, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for a cohort starting at init_age in 2022 closure_age : numeric maximum age cohort : numeric integer denoting initial cohort size n_sim : numeric integer denoting number of path simulations seed : numeric integer to be used as the seed for simulation Returns: a matrix where each row represents the number of individuals still alive from the given cohort at each age. Each row is a different path of the same cohort. An example looks like: \\[\\begin{pmatrix} 1000 & 996 & 991 & 985 & \\ldots & 0 \\\\ 1000 & 998 & 993 & 986 & \\ldots & 0 \\\\ & & \\vdots & & & \\\\ 1000 & 997 & 994 & 986 & \\ldots & 0 \\\\ 1000 & 997 & 992 & 987 & \\ldots & 0 \\end{pmatrix}\\] Note that the first column of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last column will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate life paths for cohort of 1000 females starting at age 60 sim_cohort_path_realised ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider 100 males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_cohort_path_realised ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 , cohort = 100 ) Simulate Expected Cohort Life Path sim_cohort_path_expected(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000) Parameters: init_age : numeric integer denoting initial age of cohort sex : character character denoting the gender of cohort, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for a cohort starting at init_age in 2022 closure_age : numeric maximum age cohort : numeric integer denoting initial cohort size Returns: vector of expected number of individuals still alive from a given cohort at each age An example looks like: \\[\\begin{pmatrix} 1000 & 995 & 989 & 981 & \\ldots & 0 \\end{pmatrix}\\] Note that the first entry of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last entry will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate expected life path for cohort of 1000 females starting at age 60 sim_cohort_path_expected ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider 100 males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_cohort_path_expected ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 , cohort = 100 )","title":"Simulating Life Paths"},{"location":"Aggregate%20Mortality/simulation/#simulating-life-paths","text":"One-year death probabilities derived from previous sections can also be used to simulate life paths for a single individual or a particular cohort. Each individual or cohort will be alive at a specified initial age, and deaths are sampled according to the one-year death probabilities given at each age. When simulating for an individual, the function keeps track of their dead or alive status at each age. When simulating for a cohort, the number of people still alive at each age is recorded.","title":"Simulating Life Paths"},{"location":"Aggregate%20Mortality/simulation/#simulate-individual-life-path","text":"sim_indiv_path(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, n_sim = 10000, seed = NULL) Parameters: init_age : numeric integer denoting initial age of individual sex : character character denoting the gender of individual, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for an individual starting at init_age in 2022 closure_age : numeric maximum age n_sim : numeric integer denoting number of path simulations seed : numeric integer to be used as the seed for simulation Returns: a matrix where each row is a different path of the individual's dead (-1) or alive (0) status across the years An example looks like: \\[\\begin{pmatrix} 0 & -1 & -1 & -1 & \\ldots & -1 \\\\ 0 & 0 & 0 & -1 & \\ldots & -1 \\\\ & & \\vdots & & & \\\\ 0 & 0 & 0 & 0 & \\ldots & -1 \\\\ 0 & 0 & -1 & -1 & \\ldots & -1 \\end{pmatrix}\\] Note that the first column of the matrix will always be 0 as everyone is alive at the initial age, and the last column will always be -1, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate life paths for females starting at age 60 sim_indiv_path ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_indiv_path ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 )","title":"Simulate Individual Life Path"},{"location":"Aggregate%20Mortality/simulation/#simulate-cohort-life-path","text":"sim_cohort_path_realised(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000, n_sim = 10000, seed = NULL) Parameters: init_age : numeric integer denoting initial age of cohort sex : character character denoting the gender of cohort, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for a cohort starting at init_age in 2022 closure_age : numeric maximum age cohort : numeric integer denoting initial cohort size n_sim : numeric integer denoting number of path simulations seed : numeric integer to be used as the seed for simulation Returns: a matrix where each row represents the number of individuals still alive from the given cohort at each age. Each row is a different path of the same cohort. An example looks like: \\[\\begin{pmatrix} 1000 & 996 & 991 & 985 & \\ldots & 0 \\\\ 1000 & 998 & 993 & 986 & \\ldots & 0 \\\\ & & \\vdots & & & \\\\ 1000 & 997 & 994 & 986 & \\ldots & 0 \\\\ 1000 & 997 & 992 & 987 & \\ldots & 0 \\end{pmatrix}\\] Note that the first column of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last column will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate life paths for cohort of 1000 females starting at age 60 sim_cohort_path_realised ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider 100 males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_cohort_path_realised ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 , cohort = 100 )","title":"Simulate Cohort Life Path"},{"location":"Aggregate%20Mortality/simulation/#simulate-expected-cohort-life-path","text":"sim_cohort_path_expected(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000) Parameters: init_age : numeric integer denoting initial age of cohort sex : character character denoting the gender of cohort, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for a cohort starting at init_age in 2022 closure_age : numeric maximum age cohort : numeric integer denoting initial cohort size Returns: vector of expected number of individuals still alive from a given cohort at each age An example looks like: \\[\\begin{pmatrix} 1000 & 995 & 989 & 981 & \\ldots & 0 \\end{pmatrix}\\] Note that the first entry of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last entry will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate expected life path for cohort of 1000 females starting at age 60 sim_cohort_path_expected ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider 100 males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_cohort_path_expected ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 , cohort = 100 )","title":"Simulate Expected Cohort Life Path"},{"location":"Aggregate%20Mortality/stats_functions/","text":"Summary Statistics This module includes a set of functions that output summary statistics for the survival functions generated. These include: distribution functions quantile function simulation plots (with confidence ranges) Distribution and quantile functions psurv(surv_fun, surv_time) qsurv(surv_fun, surv_prob) Parameters: surv_fun : vector survival function for a specific cohort/year with survival time rows surv_time : vector vector of survival times surv_prob : vector vector of survival probabilities Returns: vector of probabilites (distribution) or survival times (quantile) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # take vector of survival function (consider year 2017) surv_func_2017 <- surv_func [, \"2017\" ] # calculate probability of surviving 10 and 20 years psurv ( surv_func_2017 , c ( 10 , 20 )) # calculating the 80% and 95% quantile survival time qsurv ( surv_func_2017 , c ( 0.8 , 0.95 )) Survival Function Simulation Given multiple simulation paths of a survival function, the survival function for a chosen year with confidence intervals can be generated. plot_surv_sim(surv_sim, init_age, target_year, level = 95, years = NULL) Parameters: surv_sim : array survival function with survival time rows, cohort/year columns and simulation number 3rd dimension init_age : numeric integer denoting initial age of surv_sim target_year : numeric year for which the plot is made for level : numeric desired confidence level (default 95%) years : vector optional numeric vector of years for surv_sim Returns: plot of the survival function for the chosen year with confidence intervals Usage: # generate simulated rates with 'StMoMo' # install and load 'StMoMo' if the package is not loaded # fitting lee carter model on ages 55:89 AUS_StMoMo <- StMoMoData ( mortality_AUS_data , series = \"male\" ) LC <- lc ( link = \"logit\" ) # lee carter model AUS_Male_Ini_Data <- central2initial ( AUS_StMoMo ) ages_fit <- 55 : 89 wxy <- genWeightMat ( ages = ages_fit , years = AUS_Male_Ini_Data $ years , clip = 3 ) LC_fit <- fit ( LC , data = AUS_Male_Ini_Data , ages.fit = ages_fit , wxt = wxy ) # simulating rates for next 100 years set.seed ( 1234 ) n_sim <- 10 LC_sim <- simulate ( LC_fit , nsim = n_sim , h = 100 ) # using kannisto method to complete rates young_ages <- LC_sim $ ages # 55:89 old_ages <- 90 : 130 ages <- c ( young_ages , old_ages ) kannisto_sim <- complete_old_age ( rates = LC_sim $ rates , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) # create period survival function for individual aged 55 surv_sim <- rate2survival ( kannisto_sim , ages , from = \"central\" ) plot_surv_sim ( surv_sim , 55 , 2050 ) Expected Curtate Future Lifetime It may also be worthwhile to look at the expected curtate future lifetime of individuals. Historical and simulated future mortality rates will need to be merged together via the helper function combine_hist_sim , and exp_cfl calculates the expected curtate future lifetime. As there is uncertainty involved with simulating future mortality rates, the function plot_exp_cfl can generate a plot of expected curtate future lifetime with confidence intervals across years/cohorts. Combine Historical and Simulated Rates combine_hist_sim(rates_hist, rates_sim) Parameters: rates_hist : matrix historical mortality rates with age rows and cohort/year columns rates_sim : array simulated mortality rates with age rows, cohort/year columns and simulation number 3rd dimension Returns: array of combined historical and simulated rates with age rows, cohort/year columns and simulation number 3rd dimension Calculate Expected Curtate Future Lifetime exp_cfl(qx, ages, init_age = NULL, years = NULL) Parameters: qx : matrix/array 1-year death probabilities with age rows, cohort/year columns (and simulation number 3rd dimension ages : vector vector of ages for qx init_age : numeric initial age to calculate expected curtate future lifetime years : vector optional numeric vector of years for qx Returns: matrix of expected curtate future lifetime with simulation number rows and cohort/year columns Plot Expected Curtate Future Lifetime plot_exp_cfl(exp_cfl_rates, years, level = 95) Parameters: exp_cfl_rates : matrix simulated expected curtate future lifetime with simulation number rows and cohort/year columns years : vector numeric vector of years for exp_cfl_rates level : numeric desired confidence level (default 95%) Returns: plot of expected curtate future lifetime with confidence intervals across years/cohorts Usage: # generate simulated rates with 'StMoMo' # install and load 'StMoMo' if the package is not loaded # fitting lee carter model on ages 55:89 AUS_StMoMo <- StMoMoData ( mortality_AUS_data , series = \"male\" ) LC <- lc ( link = \"logit\" ) # lee carter model AUS_Male_Ini_Data <- central2initial ( AUS_StMoMo ) ages_fit <- 55 : 89 wxy <- genWeightMat ( ages = ages_fit , years = AUS_Male_Ini_Data $ years , clip = 3 ) LC_fit <- fit ( LC , data = AUS_Male_Ini_Data , ages.fit = ages_fit , wxt = wxy ) # simulating rates for next 100 years set.seed ( 1234 ) n_sim <- 10 LC_sim <- simulate ( LC_fit , nsim = n_sim , h = 100 ) # using kannisto method to complete rates young_ages <- LC_sim $ ages # 55:89 old_ages <- 90 : 130 ages <- c ( young_ages , old_ages ) rates_hist <- mortality_AUS_data $ rate $ male [ as.character ( young_ages ), ] years_hist <- as.numeric ( colnames ( rates_hist )) years_sim <- LC_sim $ years years <- c ( years_hist , years_sim ) kannisto_sim <- complete_old_age ( rates = LC_sim $ rates , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) kannisto_hist <- complete_old_age ( rates = rates_hist , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) ################# USAGE BEGINS HERE ################ # combining kannisto_55_period <- combine_hist_sim ( rates_hist = kannisto_hist , rates_sim = kannisto_sim ) # working with cohort starting from age 55 kannisto_55 <- period2cohort ( period_rates = kannisto_55_period , ages = ages ) kannisto_55_q <- rate2rate ( kannisto_55 , from = \"central\" , to = \"prob\" ) exp_cfl_kannisto <- exp_cfl ( qx = kannisto_55_q , ages = ages ) # Expected curtate future lifetime can only be computed for # the earlier (complete) cohorts exp_cfl_kannisto_clean <- exp_cfl_kannisto [, as.character ( 1970 : 2043 )] plot_exp_cfl ( exp_cfl_rates = exp_cfl_kannisto_clean , years = 1970 : 2043 )","title":"Summary Statistics"},{"location":"Aggregate%20Mortality/stats_functions/#summary-statistics","text":"This module includes a set of functions that output summary statistics for the survival functions generated. These include: distribution functions quantile function simulation plots (with confidence ranges)","title":"Summary Statistics"},{"location":"Aggregate%20Mortality/stats_functions/#distribution-and-quantile-functions","text":"psurv(surv_fun, surv_time) qsurv(surv_fun, surv_prob) Parameters: surv_fun : vector survival function for a specific cohort/year with survival time rows surv_time : vector vector of survival times surv_prob : vector vector of survival probabilities Returns: vector of probabilites (distribution) or survival times (quantile) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # take vector of survival function (consider year 2017) surv_func_2017 <- surv_func [, \"2017\" ] # calculate probability of surviving 10 and 20 years psurv ( surv_func_2017 , c ( 10 , 20 )) # calculating the 80% and 95% quantile survival time qsurv ( surv_func_2017 , c ( 0.8 , 0.95 ))","title":"Distribution and quantile functions"},{"location":"Aggregate%20Mortality/stats_functions/#survival-function-simulation","text":"Given multiple simulation paths of a survival function, the survival function for a chosen year with confidence intervals can be generated. plot_surv_sim(surv_sim, init_age, target_year, level = 95, years = NULL) Parameters: surv_sim : array survival function with survival time rows, cohort/year columns and simulation number 3rd dimension init_age : numeric integer denoting initial age of surv_sim target_year : numeric year for which the plot is made for level : numeric desired confidence level (default 95%) years : vector optional numeric vector of years for surv_sim Returns: plot of the survival function for the chosen year with confidence intervals Usage: # generate simulated rates with 'StMoMo' # install and load 'StMoMo' if the package is not loaded # fitting lee carter model on ages 55:89 AUS_StMoMo <- StMoMoData ( mortality_AUS_data , series = \"male\" ) LC <- lc ( link = \"logit\" ) # lee carter model AUS_Male_Ini_Data <- central2initial ( AUS_StMoMo ) ages_fit <- 55 : 89 wxy <- genWeightMat ( ages = ages_fit , years = AUS_Male_Ini_Data $ years , clip = 3 ) LC_fit <- fit ( LC , data = AUS_Male_Ini_Data , ages.fit = ages_fit , wxt = wxy ) # simulating rates for next 100 years set.seed ( 1234 ) n_sim <- 10 LC_sim <- simulate ( LC_fit , nsim = n_sim , h = 100 ) # using kannisto method to complete rates young_ages <- LC_sim $ ages # 55:89 old_ages <- 90 : 130 ages <- c ( young_ages , old_ages ) kannisto_sim <- complete_old_age ( rates = LC_sim $ rates , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) # create period survival function for individual aged 55 surv_sim <- rate2survival ( kannisto_sim , ages , from = \"central\" ) plot_surv_sim ( surv_sim , 55 , 2050 )","title":"Survival Function Simulation"},{"location":"Aggregate%20Mortality/stats_functions/#expected-curtate-future-lifetime","text":"It may also be worthwhile to look at the expected curtate future lifetime of individuals. Historical and simulated future mortality rates will need to be merged together via the helper function combine_hist_sim , and exp_cfl calculates the expected curtate future lifetime. As there is uncertainty involved with simulating future mortality rates, the function plot_exp_cfl can generate a plot of expected curtate future lifetime with confidence intervals across years/cohorts.","title":"Expected Curtate Future Lifetime"},{"location":"Aggregate%20Mortality/stats_functions/#combine-historical-and-simulated-rates","text":"combine_hist_sim(rates_hist, rates_sim) Parameters: rates_hist : matrix historical mortality rates with age rows and cohort/year columns rates_sim : array simulated mortality rates with age rows, cohort/year columns and simulation number 3rd dimension Returns: array of combined historical and simulated rates with age rows, cohort/year columns and simulation number 3rd dimension","title":"Combine Historical and Simulated Rates"},{"location":"Aggregate%20Mortality/stats_functions/#calculate-expected-curtate-future-lifetime","text":"exp_cfl(qx, ages, init_age = NULL, years = NULL) Parameters: qx : matrix/array 1-year death probabilities with age rows, cohort/year columns (and simulation number 3rd dimension ages : vector vector of ages for qx init_age : numeric initial age to calculate expected curtate future lifetime years : vector optional numeric vector of years for qx Returns: matrix of expected curtate future lifetime with simulation number rows and cohort/year columns","title":"Calculate Expected Curtate Future Lifetime"},{"location":"Aggregate%20Mortality/stats_functions/#plot-expected-curtate-future-lifetime","text":"plot_exp_cfl(exp_cfl_rates, years, level = 95) Parameters: exp_cfl_rates : matrix simulated expected curtate future lifetime with simulation number rows and cohort/year columns years : vector numeric vector of years for exp_cfl_rates level : numeric desired confidence level (default 95%) Returns: plot of expected curtate future lifetime with confidence intervals across years/cohorts Usage: # generate simulated rates with 'StMoMo' # install and load 'StMoMo' if the package is not loaded # fitting lee carter model on ages 55:89 AUS_StMoMo <- StMoMoData ( mortality_AUS_data , series = \"male\" ) LC <- lc ( link = \"logit\" ) # lee carter model AUS_Male_Ini_Data <- central2initial ( AUS_StMoMo ) ages_fit <- 55 : 89 wxy <- genWeightMat ( ages = ages_fit , years = AUS_Male_Ini_Data $ years , clip = 3 ) LC_fit <- fit ( LC , data = AUS_Male_Ini_Data , ages.fit = ages_fit , wxt = wxy ) # simulating rates for next 100 years set.seed ( 1234 ) n_sim <- 10 LC_sim <- simulate ( LC_fit , nsim = n_sim , h = 100 ) # using kannisto method to complete rates young_ages <- LC_sim $ ages # 55:89 old_ages <- 90 : 130 ages <- c ( young_ages , old_ages ) rates_hist <- mortality_AUS_data $ rate $ male [ as.character ( young_ages ), ] years_hist <- as.numeric ( colnames ( rates_hist )) years_sim <- LC_sim $ years years <- c ( years_hist , years_sim ) kannisto_sim <- complete_old_age ( rates = LC_sim $ rates , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) kannisto_hist <- complete_old_age ( rates = rates_hist , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) ################# USAGE BEGINS HERE ################ # combining kannisto_55_period <- combine_hist_sim ( rates_hist = kannisto_hist , rates_sim = kannisto_sim ) # working with cohort starting from age 55 kannisto_55 <- period2cohort ( period_rates = kannisto_55_period , ages = ages ) kannisto_55_q <- rate2rate ( kannisto_55 , from = \"central\" , to = \"prob\" ) exp_cfl_kannisto <- exp_cfl ( qx = kannisto_55_q , ages = ages ) # Expected curtate future lifetime can only be computed for # the earlier (complete) cohorts exp_cfl_kannisto_clean <- exp_cfl_kannisto [, as.character ( 1970 : 2043 )] plot_exp_cfl ( exp_cfl_rates = exp_cfl_kannisto_clean , years = 1970 : 2043 )","title":"Plot Expected Curtate Future Lifetime"},{"location":"Economic%20Scenario%20Generator/cts_esg/","text":"Continuous-Time Generator The continuous-time economic scenario generator simulates the trajectories of (in brackets are the $names of the output dataframes): (1) Australia zero-coupon bond rates maturing every quarter from 3 months up to 10 years, i.e., 0.25 years ( $maturity_1qtrs ), 0.5 years ( $maturity_2qtrs ), 0.75 years ( $maturity_3qtrs ), ..., 10 years ( $maturity_40qtrs ), (2) NSW home value index ( $house_index ), (3) S&P/ASX200 price ( $stock_price ). The zero-coupon bond term structure is fitted using the arbitrage-free Nelson-Siegel model, while NSW home value index and S&P/ASX200 price are assumed to be Geometric Brownian Motions that are correlated with the zero-coupon bond rates. Further details on model parameter estimation and forecast can be found in note (a) below. The independent-factor model assumes that the level, slope, and curvature of the risk-free rate are mutually independent, while the correlated-factor model assumes dependence among them. Simulations generated by the correlated-factor models are more volatile since more parameters are involved. Further suggestions on model selection can be found in section \"Choosing an Appropriate Model\" below. Denote \\(X^1\\) the level, \\(X^2\\) the slope, \\(X^3\\) the curvature of the risk-free rate, \\(X^4\\) the logged NSW home value index, \\(X^5\\) the logged S&P/ASX200 price, and \\(W^1, \\cdots, W^5\\) the standard Brownian Motions. Under the real-world measure, the independent-factor model satisfies the following stochastic differential equations: while the correlated-factor model satisfies The interest_rate models return paths generated from the first 3 equations, while the interest_house_stock models return paths generated from all 5 equations. The vector is interpreted as the mean vector, is the mean-reversion matrix, and is the covariance matrix. Estimation of these parameters are in note (a). The results are still depicted with the same simulation frequency options as the discrete case, but the calculations are based in continuous time. esg_afns_simulator(num_years = 5, num_paths = 10, frequency = 'month', perc_change = FALSE, type = 'independent', model = 'interest_rate',seed = NULL) Paramters: num_years : numeric integer denoting number of years to forecast from 01-07-2021, default 5 years num_paths : numeric integer denoting the number of simulation paths, default 10 paths frequency : character 'year', 'quarter' or 'month' denoting the simulation frequency, default 'month' perc_change : logical set TRUE for outputs to be expressed as period-by-period percent change, default FALSE. The reference level, i.e., the original values in the first output period, will be appended above the percentage changes for each variable and each trajectory. See note (b) below type : character 'independent' or 'correlated' denoting whether the latent factors are independent of each other, default 'independent' model : character 'interest_rate' or 'interest_house_stock' denoting the output variables, default 'interest_rate' seed : numeric Specify the seed for simulations, no default Returns: A list of 40 dataframes containing simulated interest rates from 01-07-2021 with maturities from 1 quarter up to 10 years if model is set to be interest_rate , or 42 dataframes containing interest rates, NSW house value index, S&P/ASX200 closing prices if model is set to be interest_house_stock . Rows are the trajectories (e.g., trajectory_1 ), columns are the time steps (e.g., 2021-07-01 ). See note (c) for explanations on the negativity of output values. Usage: # simulate 10 years of data sim <- esg_afns_simulator ( num_years = 10 , num_paths = 10 , frequency = 'year' , type = 'independent' , model = 'interest_house_stock' , seed = 1 ) # suppose we wish to look at the 3-month zero-coupon bond rates sim $ maturity_1qtrs # suppose we wish to look at the 5-year zero-coupon bond rates sim $ maturity_20qtrs # NSW house value index sim $ house_index # S&P/ASX200 closing price sim $ stock_price Choosing an Appropriate Model: Choosing between models interest_rate and interest_house_stock : The interest_house_stock model assumes dependency between interest rates, stock prices, and house indexes. Therefore, this model takes a more holistic view on the movements of those financial variables. However, a drawback is that the simulated interest_house_stock paths will be more volatile than the interest_rate model, and the paths will take longer to revert to mean levels. If users' intended area of usage is not influenced by stocks and house prices, the interest_rate model would be a good choice. If, otherwise, comovements among the financial variables are deemed important, the interest_house_stock model is suggested. Choosing between \"independent\" and \"correlated\" factor models: The correlated-factor model assumes correlation among level, slope, and curvature of the interest rate term structure, while the independent-factor model does not. Note that stock prices and house indexes are always correlated with the interest rate. The correlated-factor model takes a more holistic view on the underlying term structure of interest. Meanwhile, \"correlated\" model generates more volatile simulations, and it takes longer to revert to mean levels. Choosing between discrete- and continuous-time models: The outputs are different for the two simulators, users should choose the model based on their objectives. The base time step for discrete-time model is one quarter, whereas there is no such as a base for continuous-time. For time steps smaller than one quarter, discrete-time model will interpolate the quarterly statistics, whereas the continuous-time model simply generates random noises for each specific time step. Consequently, for large time steps, the executing time for continuous-time models are shorter than the dicrete-time model. Notes: (a) Procedure for parameter estimation: Under the real-world measure, computed measurement equation and state transition equation. Applied Kalman filtering to estimate the parameters. The maximum likelihood estimators were obtained from the Nelder-Mead algorithm. Procedure for forecasts: Used the state transition equation: Detailed R codes for parameter estimation can be found in the economic tutorial/economic. (b) Large values of percentage change can appear if the original forecasts are near-zero, or if the Gaussian noise is large, though with low probabilities. This happens especially for interest rates in the first few periods due to historical-low rates in 2021. (c) Negative simulated interest rates are allowed since the Arbitrage-Free Nelson Siegel model does not impose non-negativity constraints. On the other hand, the stock prices and home value indexes must be positive, since simulations were done using log transforms, which is an implicit assumption of Geometric Brownian Motions. References: Christensen, J. H., Diebold, F. X. & Rudebusch, G. D. (2011), \u2018The affine arbitrage-free class of nelson\u2013siegel term structure models\u2019, Journal of Econometrics 164(1), 4\u201320. Christensen, J. H., Lopez, J. A. & Rudebusch, G. D. (2015), \u2018Analytical formulas for the second moment in affine models with stochastic volatility\u2019.","title":"Continuous-Time Generator"},{"location":"Economic%20Scenario%20Generator/cts_esg/#continuous-time-generator","text":"The continuous-time economic scenario generator simulates the trajectories of (in brackets are the $names of the output dataframes): (1) Australia zero-coupon bond rates maturing every quarter from 3 months up to 10 years, i.e., 0.25 years ( $maturity_1qtrs ), 0.5 years ( $maturity_2qtrs ), 0.75 years ( $maturity_3qtrs ), ..., 10 years ( $maturity_40qtrs ), (2) NSW home value index ( $house_index ), (3) S&P/ASX200 price ( $stock_price ). The zero-coupon bond term structure is fitted using the arbitrage-free Nelson-Siegel model, while NSW home value index and S&P/ASX200 price are assumed to be Geometric Brownian Motions that are correlated with the zero-coupon bond rates. Further details on model parameter estimation and forecast can be found in note (a) below. The independent-factor model assumes that the level, slope, and curvature of the risk-free rate are mutually independent, while the correlated-factor model assumes dependence among them. Simulations generated by the correlated-factor models are more volatile since more parameters are involved. Further suggestions on model selection can be found in section \"Choosing an Appropriate Model\" below. Denote \\(X^1\\) the level, \\(X^2\\) the slope, \\(X^3\\) the curvature of the risk-free rate, \\(X^4\\) the logged NSW home value index, \\(X^5\\) the logged S&P/ASX200 price, and \\(W^1, \\cdots, W^5\\) the standard Brownian Motions. Under the real-world measure, the independent-factor model satisfies the following stochastic differential equations: while the correlated-factor model satisfies The interest_rate models return paths generated from the first 3 equations, while the interest_house_stock models return paths generated from all 5 equations. The vector is interpreted as the mean vector, is the mean-reversion matrix, and is the covariance matrix. Estimation of these parameters are in note (a). The results are still depicted with the same simulation frequency options as the discrete case, but the calculations are based in continuous time. esg_afns_simulator(num_years = 5, num_paths = 10, frequency = 'month', perc_change = FALSE, type = 'independent', model = 'interest_rate',seed = NULL) Paramters: num_years : numeric integer denoting number of years to forecast from 01-07-2021, default 5 years num_paths : numeric integer denoting the number of simulation paths, default 10 paths frequency : character 'year', 'quarter' or 'month' denoting the simulation frequency, default 'month' perc_change : logical set TRUE for outputs to be expressed as period-by-period percent change, default FALSE. The reference level, i.e., the original values in the first output period, will be appended above the percentage changes for each variable and each trajectory. See note (b) below type : character 'independent' or 'correlated' denoting whether the latent factors are independent of each other, default 'independent' model : character 'interest_rate' or 'interest_house_stock' denoting the output variables, default 'interest_rate' seed : numeric Specify the seed for simulations, no default Returns: A list of 40 dataframes containing simulated interest rates from 01-07-2021 with maturities from 1 quarter up to 10 years if model is set to be interest_rate , or 42 dataframes containing interest rates, NSW house value index, S&P/ASX200 closing prices if model is set to be interest_house_stock . Rows are the trajectories (e.g., trajectory_1 ), columns are the time steps (e.g., 2021-07-01 ). See note (c) for explanations on the negativity of output values. Usage: # simulate 10 years of data sim <- esg_afns_simulator ( num_years = 10 , num_paths = 10 , frequency = 'year' , type = 'independent' , model = 'interest_house_stock' , seed = 1 ) # suppose we wish to look at the 3-month zero-coupon bond rates sim $ maturity_1qtrs # suppose we wish to look at the 5-year zero-coupon bond rates sim $ maturity_20qtrs # NSW house value index sim $ house_index # S&P/ASX200 closing price sim $ stock_price Choosing an Appropriate Model: Choosing between models interest_rate and interest_house_stock : The interest_house_stock model assumes dependency between interest rates, stock prices, and house indexes. Therefore, this model takes a more holistic view on the movements of those financial variables. However, a drawback is that the simulated interest_house_stock paths will be more volatile than the interest_rate model, and the paths will take longer to revert to mean levels. If users' intended area of usage is not influenced by stocks and house prices, the interest_rate model would be a good choice. If, otherwise, comovements among the financial variables are deemed important, the interest_house_stock model is suggested. Choosing between \"independent\" and \"correlated\" factor models: The correlated-factor model assumes correlation among level, slope, and curvature of the interest rate term structure, while the independent-factor model does not. Note that stock prices and house indexes are always correlated with the interest rate. The correlated-factor model takes a more holistic view on the underlying term structure of interest. Meanwhile, \"correlated\" model generates more volatile simulations, and it takes longer to revert to mean levels. Choosing between discrete- and continuous-time models: The outputs are different for the two simulators, users should choose the model based on their objectives. The base time step for discrete-time model is one quarter, whereas there is no such as a base for continuous-time. For time steps smaller than one quarter, discrete-time model will interpolate the quarterly statistics, whereas the continuous-time model simply generates random noises for each specific time step. Consequently, for large time steps, the executing time for continuous-time models are shorter than the dicrete-time model. Notes: (a) Procedure for parameter estimation: Under the real-world measure, computed measurement equation and state transition equation. Applied Kalman filtering to estimate the parameters. The maximum likelihood estimators were obtained from the Nelder-Mead algorithm. Procedure for forecasts: Used the state transition equation: Detailed R codes for parameter estimation can be found in the economic tutorial/economic. (b) Large values of percentage change can appear if the original forecasts are near-zero, or if the Gaussian noise is large, though with low probabilities. This happens especially for interest rates in the first few periods due to historical-low rates in 2021. (c) Negative simulated interest rates are allowed since the Arbitrage-Free Nelson Siegel model does not impose non-negativity constraints. On the other hand, the stock prices and home value indexes must be positive, since simulations were done using log transforms, which is an implicit assumption of Geometric Brownian Motions. References: Christensen, J. H., Diebold, F. X. & Rudebusch, G. D. (2011), \u2018The affine arbitrage-free class of nelson\u2013siegel term structure models\u2019, Journal of Econometrics 164(1), 4\u201320. Christensen, J. H., Lopez, J. A. & Rudebusch, G. D. (2015), \u2018Analytical formulas for the second moment in affine models with stochastic volatility\u2019.","title":"Continuous-Time Generator"},{"location":"Economic%20Scenario%20Generator/discrete_esg/","text":"Discrete-Time Generator The discrete-time economic scenario generator simulates the trajectories of 11 Australian economic and financial variables (in brackets are the $names of the output dataframes): (1) 3-month zero-coupon bond yields ( $zcp3m_yield ), (2) 10-year zero-coupon bond spread ( $zcp10y_spread ), (3) NSW home value index ( $home_index ), (4) NSW home rental yields ( $rental_yield ), (5) Australia GDP ( $GDP ), (6) Australia CPI ( $CPI ), (7) S&P/ASX200 closing price ( $ASX200 ), (8) Australian dollar trade-weighted index ( $AUD ), (9) Australia mortgage rate ( $mortgage_rate ), (10) NSW unemployment rate ( $unemployment_rate ), (11) Stochastic discount factors ( $discount_factors ). Factors (1)-(8) (in rates) were fitted using a Vector Autoregressive model (VAR), factors (9)-(10) were respectively expressed as a fixed margin over factors (1)-(2) due to strong correlations, while factor (11) is derived from the fitted VAR model with arbitrage-free assumptions. Further details on model parameter estimation and forecasts can be found in note (a) below. Vector Autoregression (VAR) is a regression of a time series where the ouput depends linearly on the past values of itself, and the past values of other variables, up to some specfied order: where is the vector of economic variables, is the vector of intercepts, are coefficient matrices of size \\(n \\times n\\) with \\(n\\) being the number of economic variables and \\(p\\) the lags. is a vector of white noises. The stochastic discount factor is defined as: where and respectively denote the 3-month zero-coupon bond rates and white noises from the fitted VAR model, and is the market price of risk process which is assumed to be affine over factors (1)-(8). esg_var_simulator(num_years = 5, num_paths = 10, frequency = 'quarter', perc_change = FALSE, return_sdf = TRUE, seed = NULL) Parameters: num_years : numeric integer denoting number of years to forecast from 01-01-2021, default 5 years num_paths : numeric integer denoting number of simulations to make for each variable, default 10 paths frequency : character 'year', 'quarter' or 'month' denoting the simulation frequency, default 'quarter'. The base simulation time step is one quarter, Linear interpolation will be used if the required frequency is higher, whereas arithmetic average will be used if the frequency is lower. perc_change : logical set TRUE for outputs to be expressed as period-by-period percent change, default FALSE. The reference level, i.e., the original values in the first output period, will be appended above the percentage changes for each variable and each trajectory. See note (b) below. return_sdf : logical set TRUE to return the stochastic discount factors, default TRUE seed : numeric Specify the seed for simulations, no default Returns: A list of 10 dataframes containing simulated trajectories from 01-01-2021 of the 10 variables, or a list of 11 dataframes including the simulated stochastic discount factors if return_sdf is set TRUE. Rows are the trajectories (e.g., trajectory_1 ), columns are the time steps (e.g., 2021-01-01 ). See note (c) for explanations on the negativity of output values. Usage: # simulate 10 years of data sim <- esg_var_simulator ( num_years = 10 , num_paths = 10 , frequency = 'year' ) # suppose we wish to look at the 3 months zero coupon bonds sim $ zcp3m_yield # if we wanted a specific trajectory, say 3 sim $ zcp3m_yield [ 3 ,] Notes: (a) Procedure for parameter estimation: Transformed factors (3),(5)-(8) to continuously compounded growth rates, tested for correlation, causality, and stationarity. Found the optimal lag order for Vector Autoregression using AIC, SIC, HQC. Fitted the VAR model using ordinary least squares. This was followed by evaluation. Associated the stochastic discount factors with VAR factors and nominal bond prices, estimated the market price of risk parameters by minimising the sum of squared error. Procedure for forecasts: Generated factors (1)-(8) using Vector Autoregression formula. From the generated paths and noises, derived stochastic discount factors. Detailed R codes for parameter estimation can be found in the economic tutorial/economic. (b) Large values of percentage change can appear if the original forecasts are near-zero, or if the Gaussian noise is large, though with low probabilities. This happens especially for interest rates in the first few periods due to historical-low rates in 2021. (c) Negative values for rate factors i.e., factors (1)(2)(4)(9)(10), are theoretically allowed as Vector Autoregression models assume that the noise follow a Gaussian distribution. Index factors, i.e., factors (3)(5)-(8), on the other hand, are all positive. (d) Choosing between discrete- and continuous-time models: The outputs are different for the two simulators, users should choose the model based on their objectives. The base time step for discrete-time model is one quarter, whereas there is no such as a base for continuous-time. For time steps smaller than one quarter, discrete-time model will interpolate the quarterly statistics, whereas the continuous-time model simply generates random noises for each specific time step. Consequently, for large time steps, the executing time for continuous-time models are shorter than the dicrete-time model. References: Daniel H Alai, Hua Chen, Daniel Cho, Katja Hanewald, and Michael Sherris. Developing equity release markets: Risk analysis for reverse mortgages and home reversions. North American Actuarial Journal , 18(1):217\u2013241, 2014. Andrew Ang and Monika Piazzesi. A no-arbitrage vector autoregression of term structure dynamics with macroeconomic and latent variables. Journal of Monetary economics , 50(4):745\u2013787, 2003. Andrew Ang, Monika Piazzesi, and Min Wei. What does the yield curve tell us about gdp growth? Journal of econometrics , 131(1-2):359\u2013403, 2006.","title":"Discrete-Time Generator"},{"location":"Economic%20Scenario%20Generator/discrete_esg/#discrete-time-generator","text":"The discrete-time economic scenario generator simulates the trajectories of 11 Australian economic and financial variables (in brackets are the $names of the output dataframes): (1) 3-month zero-coupon bond yields ( $zcp3m_yield ), (2) 10-year zero-coupon bond spread ( $zcp10y_spread ), (3) NSW home value index ( $home_index ), (4) NSW home rental yields ( $rental_yield ), (5) Australia GDP ( $GDP ), (6) Australia CPI ( $CPI ), (7) S&P/ASX200 closing price ( $ASX200 ), (8) Australian dollar trade-weighted index ( $AUD ), (9) Australia mortgage rate ( $mortgage_rate ), (10) NSW unemployment rate ( $unemployment_rate ), (11) Stochastic discount factors ( $discount_factors ). Factors (1)-(8) (in rates) were fitted using a Vector Autoregressive model (VAR), factors (9)-(10) were respectively expressed as a fixed margin over factors (1)-(2) due to strong correlations, while factor (11) is derived from the fitted VAR model with arbitrage-free assumptions. Further details on model parameter estimation and forecasts can be found in note (a) below. Vector Autoregression (VAR) is a regression of a time series where the ouput depends linearly on the past values of itself, and the past values of other variables, up to some specfied order: where is the vector of economic variables, is the vector of intercepts, are coefficient matrices of size \\(n \\times n\\) with \\(n\\) being the number of economic variables and \\(p\\) the lags. is a vector of white noises. The stochastic discount factor is defined as: where and respectively denote the 3-month zero-coupon bond rates and white noises from the fitted VAR model, and is the market price of risk process which is assumed to be affine over factors (1)-(8). esg_var_simulator(num_years = 5, num_paths = 10, frequency = 'quarter', perc_change = FALSE, return_sdf = TRUE, seed = NULL) Parameters: num_years : numeric integer denoting number of years to forecast from 01-01-2021, default 5 years num_paths : numeric integer denoting number of simulations to make for each variable, default 10 paths frequency : character 'year', 'quarter' or 'month' denoting the simulation frequency, default 'quarter'. The base simulation time step is one quarter, Linear interpolation will be used if the required frequency is higher, whereas arithmetic average will be used if the frequency is lower. perc_change : logical set TRUE for outputs to be expressed as period-by-period percent change, default FALSE. The reference level, i.e., the original values in the first output period, will be appended above the percentage changes for each variable and each trajectory. See note (b) below. return_sdf : logical set TRUE to return the stochastic discount factors, default TRUE seed : numeric Specify the seed for simulations, no default Returns: A list of 10 dataframes containing simulated trajectories from 01-01-2021 of the 10 variables, or a list of 11 dataframes including the simulated stochastic discount factors if return_sdf is set TRUE. Rows are the trajectories (e.g., trajectory_1 ), columns are the time steps (e.g., 2021-01-01 ). See note (c) for explanations on the negativity of output values. Usage: # simulate 10 years of data sim <- esg_var_simulator ( num_years = 10 , num_paths = 10 , frequency = 'year' ) # suppose we wish to look at the 3 months zero coupon bonds sim $ zcp3m_yield # if we wanted a specific trajectory, say 3 sim $ zcp3m_yield [ 3 ,] Notes: (a) Procedure for parameter estimation: Transformed factors (3),(5)-(8) to continuously compounded growth rates, tested for correlation, causality, and stationarity. Found the optimal lag order for Vector Autoregression using AIC, SIC, HQC. Fitted the VAR model using ordinary least squares. This was followed by evaluation. Associated the stochastic discount factors with VAR factors and nominal bond prices, estimated the market price of risk parameters by minimising the sum of squared error. Procedure for forecasts: Generated factors (1)-(8) using Vector Autoregression formula. From the generated paths and noises, derived stochastic discount factors. Detailed R codes for parameter estimation can be found in the economic tutorial/economic. (b) Large values of percentage change can appear if the original forecasts are near-zero, or if the Gaussian noise is large, though with low probabilities. This happens especially for interest rates in the first few periods due to historical-low rates in 2021. (c) Negative values for rate factors i.e., factors (1)(2)(4)(9)(10), are theoretically allowed as Vector Autoregression models assume that the noise follow a Gaussian distribution. Index factors, i.e., factors (3)(5)-(8), on the other hand, are all positive. (d) Choosing between discrete- and continuous-time models: The outputs are different for the two simulators, users should choose the model based on their objectives. The base time step for discrete-time model is one quarter, whereas there is no such as a base for continuous-time. For time steps smaller than one quarter, discrete-time model will interpolate the quarterly statistics, whereas the continuous-time model simply generates random noises for each specific time step. Consequently, for large time steps, the executing time for continuous-time models are shorter than the dicrete-time model. References: Daniel H Alai, Hua Chen, Daniel Cho, Katja Hanewald, and Michael Sherris. Developing equity release markets: Risk analysis for reverse mortgages and home reversions. North American Actuarial Journal , 18(1):217\u2013241, 2014. Andrew Ang and Monika Piazzesi. A no-arbitrage vector autoregression of term structure dynamics with macroeconomic and latent variables. Journal of Monetary economics , 50(4):745\u2013787, 2003. Andrew Ang, Monika Piazzesi, and Min Wei. What does the yield curve tell us about gdp growth? Journal of econometrics , 131(1-2):359\u2013403, 2006.","title":"Discrete-Time Generator"},{"location":"Economic%20Scenario%20Generator/overview/","text":"Overview To price a financial product/instrument that will have cashflows in the future, the present time valuation requires a set of assumptions on different economic factors. The purpose of this module is to simulate a set of 11 economic variables that will characterise the economic envrionment for a specified amount of time into the future. The 10 economic factors that will be simulated are: 3-month zero-coupon yield, 10-year zero-coupon spread, NSW hedonic house value index, NSW house rental yields, Australia GDP, Australia CPI, S&P/ASX200 closing price, Australian dollar trade-weighted index, Australia mortgage rate, NSW unemployment rate, Stochastic discount factors (pricing kernels). These 11 factors can provide a comprehensive picture of the economic environment in the future, which is useful for projecting investments/financial products into the future, as well as discounting future cash flows to more accurately gauge present value. This allows for broad appliations in insurance pricing, loan/debt pricing, and project valuations. The module has a discrete-time economic scenario generator (ESG), and a continuous-time ESG. The discrete-time ESG is fit on discrete time intervals, whereas continuous-time ESG's can in theory be fit for any time point. However, the module uses the same simulation frequencies for both ESG types.","title":"Overview"},{"location":"Economic%20Scenario%20Generator/overview/#overview","text":"To price a financial product/instrument that will have cashflows in the future, the present time valuation requires a set of assumptions on different economic factors. The purpose of this module is to simulate a set of 11 economic variables that will characterise the economic envrionment for a specified amount of time into the future. The 10 economic factors that will be simulated are: 3-month zero-coupon yield, 10-year zero-coupon spread, NSW hedonic house value index, NSW house rental yields, Australia GDP, Australia CPI, S&P/ASX200 closing price, Australian dollar trade-weighted index, Australia mortgage rate, NSW unemployment rate, Stochastic discount factors (pricing kernels). These 11 factors can provide a comprehensive picture of the economic environment in the future, which is useful for projecting investments/financial products into the future, as well as discounting future cash flows to more accurately gauge present value. This allows for broad appliations in insurance pricing, loan/debt pricing, and project valuations. The module has a discrete-time economic scenario generator (ESG), and a continuous-time ESG. The discrete-time ESG is fit on discrete time intervals, whereas continuous-time ESG's can in theory be fit for any time point. However, the module uses the same simulation frequencies for both ESG types.","title":"Overview"},{"location":"Economic%20Scenario%20Generator/summary_esg/","text":"Summary statistics Period-by-period summary statistics such as quantiles, mean, and standard deviation are helpful in understanding the distribution of the simulated trajectories. We provide a R function which accepts a list or a dataframe of time series data, and returns various common choices of summary statistics. esg_summary(paths, probs = seq(0, 1, 0.25), na.rm = TRUE) Paramters: paths : a list or a dataframe List or dataframe containing time series data probs : numeric or vector Numeric vector of probabilities with values in [0,1]. Default is 0%, 25%, 50%, 75%, 100%-tiles rm.na : logical set TRUE if any NA and NaN's are removed from data before computing the statistics. Default TRUE Returns: List of dataframe containing summary statistics for each period across trajectories. Usage: # simulate 10 years of data sim <- esg_var_simulator ( num_years = 10 , num_paths = 10 , frequency = 'year' ) # obtain summary statistics for GDP data with default statistics gdp_summ <- esg_summary ( sim $ GDP ) # obtain summary statistics for 0%,20%,40%,60%,80%,100%-tiles for the whole list all_summ <- esg_summary ( sim , probs = seq ( 0 , 1 , 0.2 )) # summary statistics for self-defined dataframes test_data = as.data.frame ( matrix ( 1 : 100 , nrow = 4 , byrow = TRUE )) test_data2 = as.data.frame ( matrix ( 1001 : 2000 , nrow = 40 , byrow = TRUE )) test_list = list ( test_data , test_data2 ) esg_summary ( test_list )","title":"Summary statistics"},{"location":"Economic%20Scenario%20Generator/summary_esg/#summary-statistics","text":"Period-by-period summary statistics such as quantiles, mean, and standard deviation are helpful in understanding the distribution of the simulated trajectories. We provide a R function which accepts a list or a dataframe of time series data, and returns various common choices of summary statistics. esg_summary(paths, probs = seq(0, 1, 0.25), na.rm = TRUE) Paramters: paths : a list or a dataframe List or dataframe containing time series data probs : numeric or vector Numeric vector of probabilities with values in [0,1]. Default is 0%, 25%, 50%, 75%, 100%-tiles rm.na : logical set TRUE if any NA and NaN's are removed from data before computing the statistics. Default TRUE Returns: List of dataframe containing summary statistics for each period across trajectories. Usage: # simulate 10 years of data sim <- esg_var_simulator ( num_years = 10 , num_paths = 10 , frequency = 'year' ) # obtain summary statistics for GDP data with default statistics gdp_summ <- esg_summary ( sim $ GDP ) # obtain summary statistics for 0%,20%,40%,60%,80%,100%-tiles for the whole list all_summ <- esg_summary ( sim , probs = seq ( 0 , 1 , 0.2 )) # summary statistics for self-defined dataframes test_data = as.data.frame ( matrix ( 1 : 100 , nrow = 4 , byrow = TRUE )) test_data2 = as.data.frame ( matrix ( 1001 : 2000 , nrow = 40 , byrow = TRUE )) test_list = list ( test_data , test_data2 ) esg_summary ( test_list )","title":"Summary statistics"},{"location":"Economic%20Scenario%20Generator/top3/","text":"Topic 3 For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Topic 3"},{"location":"Economic%20Scenario%20Generator/top3/#topic-3","text":"For full documentation visit mkdocs.org .","title":"Topic 3"},{"location":"Economic%20Scenario%20Generator/top3/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Economic%20Scenario%20Generator/top3/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Health/lifetable/","text":"Life Table Generation An individual's characteristics can also be used to generate a life table with a cohort of identical traits. This can be used to calculate the probability of survival to different states. Life tables generated from the static and trend models are always deterministic, so the output will be one lifetable. Meanwhile, the frailty model will produce stochastic outputs. The lifetables outputted will be a full list of the simulated lifetables. The lifetable shows the number of people in each state at each age, and one can also choose the initial state and the initial age that the starting cohort is in. Generating a Life Table for Static and Trend Models create_life_table(trans_probs, init_age, init_state = 0, cohort = 100000) Parameters: trans_probs : list list of transition probability matrices; typically generated by 'get_trans_probs' init_age : numeric * numeric denoting initial age of individual* init_state : numeric for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state for 5-state model: 0 for H state, 1 for M state, 2 for D state, 3 for MD state cohort : numeric number of people at the beginning of the life table Returns: a list of life table matrices Usage: # for male aged 65 at wave index i, initially in the health state, using the static model with parameters 'params' trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'S' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) lifetable <- create_life_table ( trans_probs , init_age = 65 , init_state = 0 , cohort = 100000 ) Simulating a Number of Life Tables for Frailty Model simulate_life_table(n_states, model_type, param_file, init_age, female, year = 2012, init_state = 0, wave_index = 8,latent=0,n_sim=100,cohort=100000,mean=FALSE) Parameters: n_states : numeric take values 3 or 5, use 3 for 3-state model, and 5 for 5-state model model_type : character select F for Frailty model param_file : dataframe File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS for the 3-state model, and use US_HRS_5 for the 5-state-model) init_age : numeric integer denoting the initial age female : numeric 0 for male, 1 for female year : numeric integer denoting current year, required in 3-state model and ignored in 5-state model init_state : numeric for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state wave_index : numeric integer for the wave index = (interview year - 1998)/2 + 1, required in 5-state model and ignored in 3-state model latent : numeric initial value of latent factor, normally take the value 0 n_sim : numeric integer denoting number of life table simulations cohort : numeric number of people at the beginning of the life table mean : logic TRUE to return expected life table, FALSE to return all simulated life tables Returns: a list of life table matrices Usage: # for male aged 65 at wave index i, initially in the health state, using the frailty model with parameters 'params' lifetable_simulated <- simulate_life_table ( n_states = 5 , model_type = 'F' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , init_state = 0 , wave_index = 8 , latent = 0 , n_sim = 100 , cohort = 100000 , mean = FALSE )","title":"Life Table Generation"},{"location":"Health/lifetable/#life-table-generation","text":"An individual's characteristics can also be used to generate a life table with a cohort of identical traits. This can be used to calculate the probability of survival to different states. Life tables generated from the static and trend models are always deterministic, so the output will be one lifetable. Meanwhile, the frailty model will produce stochastic outputs. The lifetables outputted will be a full list of the simulated lifetables. The lifetable shows the number of people in each state at each age, and one can also choose the initial state and the initial age that the starting cohort is in.","title":"Life Table Generation"},{"location":"Health/lifetable/#generating-a-life-table-for-static-and-trend-models","text":"create_life_table(trans_probs, init_age, init_state = 0, cohort = 100000) Parameters: trans_probs : list list of transition probability matrices; typically generated by 'get_trans_probs' init_age : numeric * numeric denoting initial age of individual* init_state : numeric for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state for 5-state model: 0 for H state, 1 for M state, 2 for D state, 3 for MD state cohort : numeric number of people at the beginning of the life table Returns: a list of life table matrices Usage: # for male aged 65 at wave index i, initially in the health state, using the static model with parameters 'params' trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'S' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) lifetable <- create_life_table ( trans_probs , init_age = 65 , init_state = 0 , cohort = 100000 )","title":"Generating a Life Table for Static and Trend Models"},{"location":"Health/lifetable/#simulating-a-number-of-life-tables-for-frailty-model","text":"simulate_life_table(n_states, model_type, param_file, init_age, female, year = 2012, init_state = 0, wave_index = 8,latent=0,n_sim=100,cohort=100000,mean=FALSE) Parameters: n_states : numeric take values 3 or 5, use 3 for 3-state model, and 5 for 5-state model model_type : character select F for Frailty model param_file : dataframe File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS for the 3-state model, and use US_HRS_5 for the 5-state-model) init_age : numeric integer denoting the initial age female : numeric 0 for male, 1 for female year : numeric integer denoting current year, required in 3-state model and ignored in 5-state model init_state : numeric for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state wave_index : numeric integer for the wave index = (interview year - 1998)/2 + 1, required in 5-state model and ignored in 3-state model latent : numeric initial value of latent factor, normally take the value 0 n_sim : numeric integer denoting number of life table simulations cohort : numeric number of people at the beginning of the life table mean : logic TRUE to return expected life table, FALSE to return all simulated life tables Returns: a list of life table matrices Usage: # for male aged 65 at wave index i, initially in the health state, using the frailty model with parameters 'params' lifetable_simulated <- simulate_life_table ( n_states = 5 , model_type = 'F' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , init_state = 0 , wave_index = 8 , latent = 0 , n_sim = 100 , cohort = 100000 , mean = FALSE )","title":"Simulating a Number of Life Tables for Frailty Model"},{"location":"Health/overview/","text":"This module will produce transition probabilities for health state and functional disability models for a specified initial age (from 50 to 65 up to age 110) and health state based on the calibrated parametrization of models. Models to include static models, improvement trends in transition rates and stochastic transition rates (latent factor). Models will include functional disability based on: Various ADL\u2019s (2+, 3+, cognitive decline) with recovery Joint health status Disability states based on core activities for Australian applications Output will include: Probability transition matrices for different starting ages derived from transition rates, with trends Expected transition rates and simulated future transition rates for stochastic simulations Models will be included to forecast the Australian prevalence of disabled populations based on functional disability models.","title":"Overview"},{"location":"Health/simulation/","text":"Simulating Life Paths Expected values are easily derived from the transition probabilities, but some form of simulation is required to analyse variance of risks. Simulation can be performed by using the transition probability matrices. Everyone starts in a certain health state, and we sample movements according to the probabilities given at each age. Death state, -1, is absorbing. The other states are: 3-state model: 0: healthy 1: disabled 5-state model: 0: healthy 1: ill health but not functionally disabled 2: good health but functionally disabled 3: ill health and functionally disabled Simulating State Paths for Individuals simulate_health_state_paths(trans_probs, init_age, init_state = 0, cohort = 10000) Parameters: trans_probs : list list of transition probability matrices; typically generated by 'get_trans_probs' init_age : numeric integer denoting initial age of individual init_state : numeric for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state for 5-state model: 0 for H state, 1 for M state, 2 for D state, 3 for MD state cohort : numeric integer denoting number of people in the simulation Returns: matrix (see below for details) Usage: # simulation for 10000 males aged 65, initially healthy under the static model trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'S' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) simulated_path <- simulate_health_state_paths ( trans_probs , init_age = 65 , init_state = 0 , cohort = 10000 ) The output is a matrix where each row represents one individual's transition into different states at each year of their life. An example looks like: \\[\\begin{bmatrix} 0 & 0 & 1 & 1 & \\ldots & -1\\\\ 0 & 0 & 2 & 2 & \\ldots & 3 \\\\ & & \\vdots & & & \\\\ 0 & -1 & -1 & -1 & \\ldots & -1 \\\\ 0 & 0 & 3 & 2 & \\ldots & 2 \\end{bmatrix}\\] Note The first column of the matrix will always be initial state provided in the parameters.","title":"Simulating Life Paths"},{"location":"Health/simulation/#simulating-life-paths","text":"Expected values are easily derived from the transition probabilities, but some form of simulation is required to analyse variance of risks. Simulation can be performed by using the transition probability matrices. Everyone starts in a certain health state, and we sample movements according to the probabilities given at each age. Death state, -1, is absorbing. The other states are: 3-state model: 0: healthy 1: disabled 5-state model: 0: healthy 1: ill health but not functionally disabled 2: good health but functionally disabled 3: ill health and functionally disabled","title":"Simulating Life Paths"},{"location":"Health/simulation/#simulating-state-paths-for-individuals","text":"simulate_health_state_paths(trans_probs, init_age, init_state = 0, cohort = 10000) Parameters: trans_probs : list list of transition probability matrices; typically generated by 'get_trans_probs' init_age : numeric integer denoting initial age of individual init_state : numeric for 3-state model: integer value of 0 or 1, where 0 for healthy state, 1 for disabled state for 5-state model: 0 for H state, 1 for M state, 2 for D state, 3 for MD state cohort : numeric integer denoting number of people in the simulation Returns: matrix (see below for details) Usage: # simulation for 10000 males aged 65, initially healthy under the static model trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'S' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) simulated_path <- simulate_health_state_paths ( trans_probs , init_age = 65 , init_state = 0 , cohort = 10000 ) The output is a matrix where each row represents one individual's transition into different states at each year of their life. An example looks like: \\[\\begin{bmatrix} 0 & 0 & 1 & 1 & \\ldots & -1\\\\ 0 & 0 & 2 & 2 & \\ldots & 3 \\\\ & & \\vdots & & & \\\\ 0 & -1 & -1 & -1 & \\ldots & -1 \\\\ 0 & 0 & 3 & 2 & \\ldots & 2 \\end{bmatrix}\\] Note The first column of the matrix will always be initial state provided in the parameters.","title":"Simulating State Paths for Individuals"},{"location":"Health/trans_probs/","text":"Transition Probability Matrix The Cox Hazard model produces continuous hazard rates that will be discretized to produce piecewise constant rates. The process is repeated for each of the transition rates (4 transitions for 3-state model, and 12 transitions for 5-state model). The rates at each age are combined into transition rate matrices for that age. Taking the matrix exponential changes that to transition probability matrices. Note The transition probability matrices are deterministic for each individual with the Static and Trend models, but stochastic with the Frailty model. Get a List of Transition Probability Matrices from Initial Age to Age 110 get_trans_probs(n_states, model_type, param_file, init_age, female, year = 2012, wave_index = 8, latent = 0) Parameters n_states : numeric take values 3 or 5, use 3 for 3-state model, and 5 for 5-state model model_type : character 'S' for static model, 'T' for trend model, 'F' for frailty model param_file : dataframe File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS for the 3-state model, and use US_HRS_5 for the 5-state-model) init_age : numeric integer denoting the initial age female : numeric 0 for male, 1 for female year : numeric integer denoting current year, required in 3-state model and ignored in 5-state model wave_index : numeric integer for the wave index = (interview year - 1998)/2 + 1, required in 5-state model and ignored in 3-state model latent : numeric initial value of latent factor, normally take the value 0 Returns: List of 3x3 or 5x5 transition probability matrices, from the initial age to age 110. Usage: # for male aged 65 at wave index i, using the 5-state frailty model with US_HRS_5 parameters trans_probs = get_trans_probs ( n_states = 5 , model_type = 'F' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 )","title":"Transition Probability Matrix"},{"location":"Health/trans_probs/#transition-probability-matrix","text":"The Cox Hazard model produces continuous hazard rates that will be discretized to produce piecewise constant rates. The process is repeated for each of the transition rates (4 transitions for 3-state model, and 12 transitions for 5-state model). The rates at each age are combined into transition rate matrices for that age. Taking the matrix exponential changes that to transition probability matrices. Note The transition probability matrices are deterministic for each individual with the Static and Trend models, but stochastic with the Frailty model.","title":"Transition Probability Matrix"},{"location":"Health/trans_probs/#get-a-list-of-transition-probability-matrices-from-initial-age-to-age-110","text":"get_trans_probs(n_states, model_type, param_file, init_age, female, year = 2012, wave_index = 8, latent = 0) Parameters n_states : numeric take values 3 or 5, use 3 for 3-state model, and 5 for 5-state model model_type : character 'S' for static model, 'T' for trend model, 'F' for frailty model param_file : dataframe File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS for the 3-state model, and use US_HRS_5 for the 5-state-model) init_age : numeric integer denoting the initial age female : numeric 0 for male, 1 for female year : numeric integer denoting current year, required in 3-state model and ignored in 5-state model wave_index : numeric integer for the wave index = (interview year - 1998)/2 + 1, required in 5-state model and ignored in 3-state model latent : numeric initial value of latent factor, normally take the value 0 Returns: List of 3x3 or 5x5 transition probability matrices, from the initial age to age 110. Usage: # for male aged 65 at wave index i, using the 5-state frailty model with US_HRS_5 parameters trans_probs = get_trans_probs ( n_states = 5 , model_type = 'F' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 )","title":"Get a List of Transition Probability Matrices from Initial Age to Age 110"},{"location":"Health/workflow/","text":"Workflow Example The following is an example of the general workflow of the module. It demonstrates the order of function executions, and the different endpoint outputs. We use the following individual characteristics: male age 87 initial year 2022 trend model healthy use parameters estimated from the US study: US_HRS for 3-state model and US_HRS_5 for 5-state model # first we create a list of transition probability matrices trans_probs_3 <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 87 , female = 0 , year = 2022 , latent = 0 ) # using the transition probabilities, we can generate life tables lifetable <- create_life_table ( trans_probs_3 , init_age = 87 , init_state = 0 , cohort = 100000 ) head ( lifetable ) # can also create a plot of mortality and disability curves prob_plots ( init_state = 0 , 87 , trans_probs_3 ) Statistics for 3-state models: # from transition probabilities, we can simulate lifetime paths sim_paths_3 <- simulate_health_state_paths ( trans_probs_3 , init_age = 87 , init_state = 0 , cohort = 10000 ) # statistics (mean and standard deviation): # average future lifetime future_life <- health3_afl ( 87 , init_state = 0 , trans_probs_3 ) # healthy future lifetime healthy_life <- health3_hfl ( 87 , init_state = 0 , trans_probs_3 ) # average future lifetime spent in disabled state disabled_life <- health3_dfl ( 87 , init_state = 0 , trans_probs_3 ) # time until onset of disability first_disabled <- health3_time_to_disabled ( 87 , trans_probs_3 ) # all survival statistics (essentially all of the above outputted in one dataframe) health3_survival_stats ( 87 , init_state = 0 , trans_probs_3 ) Statistics for 5-state models: # first we create a list of transition probability matrices for the 5-state model trans_probs_5 <- get_trans_probs ( n_states = 5 , model_type = 'T' , param_file = US_HRS_5 , init_age = 87 , female = 0 , wave_index = 13 , latent = 0 ) # from transition probabilities, we can simulate lifetime paths sim_paths_5 <- simulate_health_state_paths ( trans_probs_5 , init_age = 87 , init_state = 0 , cohort = 10000 ) # statistics (mean and standard deviation): # average future lifetime total_time_alive <- health5_total_time_stats ( sim_paths_5 , 4 ) # healthy future lifetime total_time_healthy <- health5_total_time_stats ( sim_paths_5 , 0 ) # average future lifetime spent in M state total_time_M <- health5_total_time_stats ( sim_paths_5 , 1 ) # time until leaving H state first_time_H <- health5_first_time_stats ( sim_paths_5 , 0 )","title":"Workflow Example"},{"location":"Health/workflow/#workflow-example","text":"The following is an example of the general workflow of the module. It demonstrates the order of function executions, and the different endpoint outputs. We use the following individual characteristics: male age 87 initial year 2022 trend model healthy use parameters estimated from the US study: US_HRS for 3-state model and US_HRS_5 for 5-state model # first we create a list of transition probability matrices trans_probs_3 <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 87 , female = 0 , year = 2022 , latent = 0 ) # using the transition probabilities, we can generate life tables lifetable <- create_life_table ( trans_probs_3 , init_age = 87 , init_state = 0 , cohort = 100000 ) head ( lifetable ) # can also create a plot of mortality and disability curves prob_plots ( init_state = 0 , 87 , trans_probs_3 ) Statistics for 3-state models: # from transition probabilities, we can simulate lifetime paths sim_paths_3 <- simulate_health_state_paths ( trans_probs_3 , init_age = 87 , init_state = 0 , cohort = 10000 ) # statistics (mean and standard deviation): # average future lifetime future_life <- health3_afl ( 87 , init_state = 0 , trans_probs_3 ) # healthy future lifetime healthy_life <- health3_hfl ( 87 , init_state = 0 , trans_probs_3 ) # average future lifetime spent in disabled state disabled_life <- health3_dfl ( 87 , init_state = 0 , trans_probs_3 ) # time until onset of disability first_disabled <- health3_time_to_disabled ( 87 , trans_probs_3 ) # all survival statistics (essentially all of the above outputted in one dataframe) health3_survival_stats ( 87 , init_state = 0 , trans_probs_3 ) Statistics for 5-state models: # first we create a list of transition probability matrices for the 5-state model trans_probs_5 <- get_trans_probs ( n_states = 5 , model_type = 'T' , param_file = US_HRS_5 , init_age = 87 , female = 0 , wave_index = 13 , latent = 0 ) # from transition probabilities, we can simulate lifetime paths sim_paths_5 <- simulate_health_state_paths ( trans_probs_5 , init_age = 87 , init_state = 0 , cohort = 10000 ) # statistics (mean and standard deviation): # average future lifetime total_time_alive <- health5_total_time_stats ( sim_paths_5 , 4 ) # healthy future lifetime total_time_healthy <- health5_total_time_stats ( sim_paths_5 , 0 ) # average future lifetime spent in M state total_time_M <- health5_total_time_stats ( sim_paths_5 , 1 ) # time until leaving H state first_time_H <- health5_first_time_stats ( sim_paths_5 , 0 )","title":"Workflow Example"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/","text":"3-State Model General Principle The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for an individual \\(k\\) and transition type \\(s\\) is: \\[\\lambda_{k, s}(t) = \\text{exp}(\\boldsymbol{\\beta}_{s}'\\mathbf{X}_k) \\cdot H_{k, s}(t)\\] In the above forumlation, \\(\\boldsymbol{\\beta}\\) contains coefficients of transition type \\(s\\) to be estimated, and \\(\\mathbf{X}\\) contains the covariates of individual \\(k\\) . Furthermore, we assume the Markovaian property where \\(H_{k, s}(t) = 1\\) . Three Models Static Model \\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k \\] where \\(x_k(t)\\) represents the age for the \\(k\\) th individual at time t and \\(F_k = 1\\) if the \\(k\\) th individual is female. The coefficients are parameters to be estimated. Trend Model \\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t \\] where \\(t\\) is the time trend. Note that \\(t=1\\) corresponds to the year 1998-1999. Frailty Model \\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t + \\alpha_s \\psi(t) \\] where \\(\\psi(t)\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi(t) = \\psi(t-1) + \\epsilon\\) with \\(\\epsilon \\sim \\text{N}(0, 1)\\) . Parameters The module uses cox hazard model parameters estimated from external research studies. The parameters of the two following studies are included in the package: US Health and Retirement Study (parameter name: US_HRS) China Chinese Longitudinal Healthy Longevity Survey (parameter name: china_CLHLS)","title":"3-State Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#3-state-model","text":"","title":"3-State Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#general-principle","text":"The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for an individual \\(k\\) and transition type \\(s\\) is: \\[\\lambda_{k, s}(t) = \\text{exp}(\\boldsymbol{\\beta}_{s}'\\mathbf{X}_k) \\cdot H_{k, s}(t)\\] In the above forumlation, \\(\\boldsymbol{\\beta}\\) contains coefficients of transition type \\(s\\) to be estimated, and \\(\\mathbf{X}\\) contains the covariates of individual \\(k\\) . Furthermore, we assume the Markovaian property where \\(H_{k, s}(t) = 1\\) .","title":"General Principle"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#three-models","text":"","title":"Three Models"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#static-model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k \\] where \\(x_k(t)\\) represents the age for the \\(k\\) th individual at time t and \\(F_k = 1\\) if the \\(k\\) th individual is female. The coefficients are parameters to be estimated.","title":"Static Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#trend-model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t \\] where \\(t\\) is the time trend. Note that \\(t=1\\) corresponds to the year 1998-1999.","title":"Trend Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#frailty-model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t + \\alpha_s \\psi(t) \\] where \\(\\psi(t)\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi(t) = \\psi(t-1) + \\epsilon\\) with \\(\\epsilon \\sim \\text{N}(0, 1)\\) .","title":"Frailty Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_3/#parameters","text":"The module uses cox hazard model parameters estimated from external research studies. The parameters of the two following studies are included in the package: US Health and Retirement Study (parameter name: US_HRS) China Chinese Longitudinal Healthy Longevity Survey (parameter name: china_CLHLS)","title":"Parameters"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/","text":"5-State Model General Principle The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for an individual \\(k\\) and transition type \\(s\\) is: \\[\\lambda_{k, s}(t)=\\exp \\left\\{\\beta_{s}+\\gamma_{s}^{\\prime} w_{k}(t)+\\alpha_{s} \\psi(t)\\right\\}\\] In the above forumlation, \\(\\beta_{s}\\) is the baseline log-intensity for transition type \\(s\\) , \\(w_{k}(t)\\) contains the age and gender of the individuals, \\(\\gamma_{s}^{\\prime}\\) measure the sensitivity to age and gender, \\(\\psi(t)\\) is a latent process that captures the uncertainty, and \\(\\alpha_{s}\\) measures the sensitivity to the latent process. Three Models Static Model \\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k},\\] where \\(x_k(t)\\) represents the age for the \\(k\\) th individual at time t and \\(F_k = 1\\) if the \\(k\\) th individual is female. The coefficients are parameters to be estimated. Trend Model \\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i,\\] where \\(i\\) is the index number of the interview indicating the time trend. Note that \\(i=1\\) corresponds to the interview year 1998, and the interview is taken every two years. Therefore, i=(interview year - 1998)/2 + 1. Frailty Model \\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i+\\alpha_{s} \\psi_{i},\\] where \\(\\psi_{i}\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi_{i} = \\psi_{i-1} + \\epsilon_{i}\\) with \\(\\epsilon_{i} \\sim \\text{N}(0, 1)\\) . Parameters The module uses cox hazard model parameters estimated from external research studies. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty The estimated parameters of the static, trend, and frailty models from the above study with the US HRS data are embedded in the module: US Health and Retirement Study (parameter name: US_HRS_5)","title":"5-State Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#5-state-model","text":"","title":"5-State Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#general-principle","text":"The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for an individual \\(k\\) and transition type \\(s\\) is: \\[\\lambda_{k, s}(t)=\\exp \\left\\{\\beta_{s}+\\gamma_{s}^{\\prime} w_{k}(t)+\\alpha_{s} \\psi(t)\\right\\}\\] In the above forumlation, \\(\\beta_{s}\\) is the baseline log-intensity for transition type \\(s\\) , \\(w_{k}(t)\\) contains the age and gender of the individuals, \\(\\gamma_{s}^{\\prime}\\) measure the sensitivity to age and gender, \\(\\psi(t)\\) is a latent process that captures the uncertainty, and \\(\\alpha_{s}\\) measures the sensitivity to the latent process.","title":"General Principle"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#three-models","text":"","title":"Three Models"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#static-model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k},\\] where \\(x_k(t)\\) represents the age for the \\(k\\) th individual at time t and \\(F_k = 1\\) if the \\(k\\) th individual is female. The coefficients are parameters to be estimated.","title":"Static Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#trend-model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i,\\] where \\(i\\) is the index number of the interview indicating the time trend. Note that \\(i=1\\) corresponds to the interview year 1998, and the interview is taken every two years. Therefore, i=(interview year - 1998)/2 + 1.","title":"Trend Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#frailty-model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i+\\alpha_{s} \\psi_{i},\\] where \\(\\psi_{i}\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi_{i} = \\psi_{i-1} + \\epsilon_{i}\\) with \\(\\epsilon_{i} \\sim \\text{N}(0, 1)\\) .","title":"Frailty Model"},{"location":"Health/Cox%20Hazard%20Regression/cox_model_5/#parameters","text":"The module uses cox hazard model parameters estimated from external research studies. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty The estimated parameters of the static, trend, and frailty models from the above study with the US HRS data are embedded in the module: US Health and Retirement Study (parameter name: US_HRS_5)","title":"Parameters"},{"location":"Health/Multi%20State%20Model/3_state_model/","text":"3-State Model This module conducts mortality analysis using the 3 state model with the following transitions: The three states are: H: Healthy F: Disabled D: Dead Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. Functionalities of the module includes: Calculating transition probability matrices from parameters of Cox Regression model Creating life tables for a certain individual characteristic Simulating lifetime paths Returning key survival statistics for a certain individual These functions can be helpful in conducting mortality studies, as well as applications in insurance pricing. The general overview and usage of the module can be seen in the following flowchart:","title":"3-State Model"},{"location":"Health/Multi%20State%20Model/3_state_model/#3-state-model","text":"This module conducts mortality analysis using the 3 state model with the following transitions: The three states are: H: Healthy F: Disabled D: Dead Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. Functionalities of the module includes: Calculating transition probability matrices from parameters of Cox Regression model Creating life tables for a certain individual characteristic Simulating lifetime paths Returning key survival statistics for a certain individual These functions can be helpful in conducting mortality studies, as well as applications in insurance pricing. The general overview and usage of the module can be seen in the following flowchart:","title":"3-State Model"},{"location":"Health/Multi%20State%20Model/5_state_model/","text":"# 5-State Model This module conducts mortality analysis using the 5 state model with the following transitions: The five states are: H: Healthy and not functionally disabled D: Healthy and functionally disabled M: Ill health and not functionally disabled MD: Ill health and functionally disabled Dead Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty The transition types are numbered from 1 to 12 illustrated in the table below. Functionalities of the module includes: Calculating transition probability matrices from parameters of Cox Regression model Creating life tables for a certain individual characteristic Simulating lifetime paths Returning key survival statistics for a certain individual These functions can be helpful in conducting mortality studies, as well as applications in insurance pricing.","title":"5-State Model"},{"location":"Health/Multi%20State%20Model/5_state_model/#5-state-model","text":"This module conducts mortality analysis using the 5 state model with the following transitions: The five states are: H: Healthy and not functionally disabled D: Healthy and functionally disabled M: Ill health and not functionally disabled MD: Ill health and functionally disabled Dead Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty The transition types are numbered from 1 to 12 illustrated in the table below. Functionalities of the module includes: Calculating transition probability matrices from parameters of Cox Regression model Creating life tables for a certain individual characteristic Simulating lifetime paths Returning key survival statistics for a certain individual These functions can be helpful in conducting mortality studies, as well as applications in insurance pricing.","title":"# 5-State Model"},{"location":"Health/Statistics/stats_3/","text":"3-State Model A lot of mortality statistics can be generated to analyse survival of a certain individual. The following functions return the expected value and variance associated with the lifetime statistic. The functions can use either of the different inputs below to produce the required statistic: list of transition probability matrices from get_trans_probs simulated path matrix from simulate_health_state_paths If the first option is used, the functions use simulation to find expected value and variance. Hence, there is a stochastic component to these results. If both inputs are provided, then the simulated path wil be used, and no simulation will occur within the function. Each function comes with a frailty version, which has the same name with an 'F' attached to it (eg. health3_afl -> health3_aflF ). The frailty version simulates 'n' unique latent paths, which adds another level of randomness in the statistic. It also requires the same parameters needed to produce a new set of transition probability matrices (see below examples). By default, frailty functions simulate 1000 unique latent factors. For all code examples below, we will use a male individual aged 65 in year 2022. Average Future Lifetime: health3_afl ( health3_aflF ) The function calculates the average future lifetime for a given individual, and its variance. health3_afl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of average future lifetime Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate average future lifetime health3_afl ( 65 , init_state = 0 , trans_probs ) health3_aflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of average future lifetime Usage: health3_aflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS ) Healthy Future Lifetime health3_hfl ( health3_hflF ) This function calculates the average future lifetime spent in the healthy state, and its variance. health3_hfl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of healthy future lifetime Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate healthy future lifetime health3_hfl ( 65 , init_state = 0 , trans_probs ) health3_hflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of healthy future lifetime Usage: health3_hflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS ) Average Disabled Future Lifetime: health3_dfl ( health3_dflF ) This function calculates the average future lifetime spent in the disabled state, and its variance. Not that under the same simulated lifetime, average future lifetime is equal to the sum of healthy lifetime and disabled lifetime. health3_dfl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of average lifetime spent in disabled state Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate average future lifetime in disabled state health3_dfl ( 65 , init_state = 0 , trans_probs ) health3_dflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of average future lifetime in disabled state Usage: health3_dflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS ) Time until onset of Disability: health3_time_to_disabled ( health3_time_to_disabledF ) This function calculates average time for onset of disability, given that the individual becomes disabled. Note that an initial state is not required for this function, as disabled initial state is trivial. health3_time_to_disabled(init_age, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of onset of first diability Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate time until onset of disability health3_time_to_disabled ( 65 , trans_probs ) health3_time_to_disabledF(init_age, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of individual female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of onset of first disability Usage: health3_time_to_disabledF ( 65 , female = 0 , 2022 , US_HRS ) All Survival Stats: health3_survival_stats ( health3_survival_statsF ) A combination of all the above functions. If transition probabilities are provided, then one simulation is run and all the statistics are calculated from that simulation (this is to keep results consistent). A simulated pathway can also be provided. Time until onset of disability is not returned if initial state is set to 1 as it is trivial. The function returns all the information (mean and variance of each statistic) as a dataframe. health3_survival_stats(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of all statistics Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate all statistics health3_survival_stats ( 65 , init_state = 0 , trans_probs ) health3_survival_statsF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of all statistics Usage: health3_survival_statsF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"3-State Model"},{"location":"Health/Statistics/stats_3/#3-state-model","text":"A lot of mortality statistics can be generated to analyse survival of a certain individual. The following functions return the expected value and variance associated with the lifetime statistic. The functions can use either of the different inputs below to produce the required statistic: list of transition probability matrices from get_trans_probs simulated path matrix from simulate_health_state_paths If the first option is used, the functions use simulation to find expected value and variance. Hence, there is a stochastic component to these results. If both inputs are provided, then the simulated path wil be used, and no simulation will occur within the function. Each function comes with a frailty version, which has the same name with an 'F' attached to it (eg. health3_afl -> health3_aflF ). The frailty version simulates 'n' unique latent paths, which adds another level of randomness in the statistic. It also requires the same parameters needed to produce a new set of transition probability matrices (see below examples). By default, frailty functions simulate 1000 unique latent factors. For all code examples below, we will use a male individual aged 65 in year 2022.","title":"3-State Model"},{"location":"Health/Statistics/stats_3/#average-future-lifetime-health3_afl-health3_aflf","text":"The function calculates the average future lifetime for a given individual, and its variance. health3_afl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of average future lifetime Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate average future lifetime health3_afl ( 65 , init_state = 0 , trans_probs ) health3_aflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of average future lifetime Usage: health3_aflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"Average Future Lifetime: health3_afl (health3_aflF)"},{"location":"Health/Statistics/stats_3/#healthy-future-lifetime-health3_hfl-health3_hflf","text":"This function calculates the average future lifetime spent in the healthy state, and its variance. health3_hfl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of healthy future lifetime Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate healthy future lifetime health3_hfl ( 65 , init_state = 0 , trans_probs ) health3_hflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of healthy future lifetime Usage: health3_hflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"Healthy Future Lifetime health3_hfl (health3_hflF)"},{"location":"Health/Statistics/stats_3/#average-disabled-future-lifetime-health3_dfl-health3_dflf","text":"This function calculates the average future lifetime spent in the disabled state, and its variance. Not that under the same simulated lifetime, average future lifetime is equal to the sum of healthy lifetime and disabled lifetime. health3_dfl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of average lifetime spent in disabled state Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate average future lifetime in disabled state health3_dfl ( 65 , init_state = 0 , trans_probs ) health3_dflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of average future lifetime in disabled state Usage: health3_dflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"Average Disabled Future Lifetime: health3_dfl (health3_dflF)"},{"location":"Health/Statistics/stats_3/#time-until-onset-of-disability-health3_time_to_disabled-health3_time_to_disabledf","text":"This function calculates average time for onset of disability, given that the individual becomes disabled. Note that an initial state is not required for this function, as disabled initial state is trivial. health3_time_to_disabled(init_age, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of onset of first diability Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate time until onset of disability health3_time_to_disabled ( 65 , trans_probs ) health3_time_to_disabledF(init_age, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of individual female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of onset of first disability Usage: health3_time_to_disabledF ( 65 , female = 0 , 2022 , US_HRS )","title":"Time until onset of Disability: health3_time_to_disabled (health3_time_to_disabledF)"},{"location":"Health/Statistics/stats_3/#all-survival-stats-health3_survival_stats-health3_survival_statsf","text":"A combination of all the above functions. If transition probabilities are provided, then one simulation is run and all the statistics are calculated from that simulation (this is to keep results consistent). A simulated pathway can also be provided. Time until onset of disability is not returned if initial state is set to 1 as it is trivial. The function returns all the information (mean and variance of each statistic) as a dataframe. health3_survival_stats(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of all statistics Usage: # trend model trans_probs <- get_trans_probs ( n_states = 3 , model_type = 'T' , param_file = US_HRS , init_age = 65 , female = 0 , year = 2022 ) # calculate all statistics health3_survival_stats ( 65 , init_state = 0 , trans_probs ) health3_survival_statsF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of individual init_state : numeric initial state of individual: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of all statistics Usage: health3_survival_statsF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"All Survival Stats: health3_survival_stats (health3_survival_statsF)"},{"location":"Health/Statistics/stats_5/","text":"5-State Model With the use of simulated paths, a lot of mortality statistics can be generated to analyse or simply gain insight into the survival characteristics of certain individuals. For the 5 state model, we use the simulated paths as inputs to calculate: the average time of entering a certain state (such as the D state: Healthy and functionally disabled) the total time spent in each state As results are stochastic (statistics are derived from random simulated lifetimes), we can also study the variance of these statistics. This will be beneficial in quantifying the risk, allowing for more robust pricing methods. Average First Time Entering State health5_first_time_stats(simulated_path, state) Parameters: simulated_path : matrix matrix containing life time simulations, obtained from function \"simulate_health_state_paths\" state : numeric integer denoting which state we are entering or leaving 0 for first time leaving H state, only used when initial state is 0 1 for first time entering M state 2 for first time entering D state 3 for first time entering MD state -1 for first time entering the dead state Returns: column vector of first time entering the specified state Usage: # simulation of 10000 males aged 65 initially healthy under the trend model trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'T' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) simulated_path <- simulate_health_state_paths ( trans_probs , init_age = 65 , init_state = 0 , cohort = 10000 ) # time until entering M state, ill health but not functionally disabled time_to_M <- health5_first_time_stats ( simulated_path , 1 ) # average initial time of entering state 1 print ( mean ( time_to_M , na.rm = TRUE )) Total Time Spent in State health5_total_time_stats(simulated_path, state) Parameters: simulated_path : matrix matrix containing life time simulations, obtained from function \"simulate_health_state_paths\" state : numeric integer denoting which state we are counting 0 for total time in H state 1 for total time in M state 2 for total time in D state 3 for total time in MD state -1 for total time in dead state 4 for total time alive or not in dead state Returns: column vector of total times spent in specified state Usage: # simulation of 10000 males aged 65 initially healthy under the trend model trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'T' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) simulated_path <- simulate_health_state_paths ( trans_probs , init_age = 65 , init_state = 0 , cohort = 10000 ) # total time spent in MD state, ill health and functionally disabled total_state_MD <- health5_total_time_stats ( simulated_path , 3 ) # average time spent in state MD print ( mean ( total_state_MD )) Produce Mean and Variance from Output This function is a 'helper' function, used in conjunction with the ouput of the previous functions to create the mean and variance of those statistics. health5_stats_produce(input) Parameters: input : matrix n \\(\\times\\) 1 matrix of statistics Returns mean and variance of the statistics inputted Usage: # simulation of 10000 males aged 65 initially healthy under the trend model trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'T' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) simulated_path <- simulate_health_state_paths ( trans_probs , init_age = 65 , init_state = 0 , cohort = 10000 ) # time until entering M state, ill health but not functionally disabled time_to_M <- health5_first_time_stats ( simulated_path , 1 ) # total time spent in MD state, ill health and functionally disabled total_time_state_MD <- health5_total_time_stats ( simulated_path , 3 ) # produce mean and variance of first time into M state first_time_M_stats <- health5_stats_produce ( time_to_M ) # produce mean and variance of time spent in MD state total_time_in_MD_stats <- health5_stats_produce ( total_time_state_MD )","title":"5-State Model"},{"location":"Health/Statistics/stats_5/#5-state-model","text":"With the use of simulated paths, a lot of mortality statistics can be generated to analyse or simply gain insight into the survival characteristics of certain individuals. For the 5 state model, we use the simulated paths as inputs to calculate: the average time of entering a certain state (such as the D state: Healthy and functionally disabled) the total time spent in each state As results are stochastic (statistics are derived from random simulated lifetimes), we can also study the variance of these statistics. This will be beneficial in quantifying the risk, allowing for more robust pricing methods.","title":"5-State Model"},{"location":"Health/Statistics/stats_5/#average-first-time-entering-state","text":"health5_first_time_stats(simulated_path, state) Parameters: simulated_path : matrix matrix containing life time simulations, obtained from function \"simulate_health_state_paths\" state : numeric integer denoting which state we are entering or leaving 0 for first time leaving H state, only used when initial state is 0 1 for first time entering M state 2 for first time entering D state 3 for first time entering MD state -1 for first time entering the dead state Returns: column vector of first time entering the specified state Usage: # simulation of 10000 males aged 65 initially healthy under the trend model trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'T' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) simulated_path <- simulate_health_state_paths ( trans_probs , init_age = 65 , init_state = 0 , cohort = 10000 ) # time until entering M state, ill health but not functionally disabled time_to_M <- health5_first_time_stats ( simulated_path , 1 ) # average initial time of entering state 1 print ( mean ( time_to_M , na.rm = TRUE ))","title":"Average First Time Entering State"},{"location":"Health/Statistics/stats_5/#total-time-spent-in-state","text":"health5_total_time_stats(simulated_path, state) Parameters: simulated_path : matrix matrix containing life time simulations, obtained from function \"simulate_health_state_paths\" state : numeric integer denoting which state we are counting 0 for total time in H state 1 for total time in M state 2 for total time in D state 3 for total time in MD state -1 for total time in dead state 4 for total time alive or not in dead state Returns: column vector of total times spent in specified state Usage: # simulation of 10000 males aged 65 initially healthy under the trend model trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'T' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) simulated_path <- simulate_health_state_paths ( trans_probs , init_age = 65 , init_state = 0 , cohort = 10000 ) # total time spent in MD state, ill health and functionally disabled total_state_MD <- health5_total_time_stats ( simulated_path , 3 ) # average time spent in state MD print ( mean ( total_state_MD ))","title":"Total Time Spent in State"},{"location":"Health/Statistics/stats_5/#produce-mean-and-variance-from-output","text":"This function is a 'helper' function, used in conjunction with the ouput of the previous functions to create the mean and variance of those statistics. health5_stats_produce(input) Parameters: input : matrix n \\(\\times\\) 1 matrix of statistics Returns mean and variance of the statistics inputted Usage: # simulation of 10000 males aged 65 initially healthy under the trend model trans_probs <- get_trans_probs ( n_states = 5 , model_type = 'T' , param_file = US_HRS_5 , init_age = 65 , female = 0 , year = 2012 , wave_index = 8 , latent = 0 ) simulated_path <- simulate_health_state_paths ( trans_probs , init_age = 65 , init_state = 0 , cohort = 10000 ) # time until entering M state, ill health but not functionally disabled time_to_M <- health5_first_time_stats ( simulated_path , 1 ) # total time spent in MD state, ill health and functionally disabled total_time_state_MD <- health5_total_time_stats ( simulated_path , 3 ) # produce mean and variance of first time into M state first_time_M_stats <- health5_stats_produce ( time_to_M ) # produce mean and variance of time spent in MD state total_time_in_MD_stats <- health5_stats_produce ( total_time_state_MD )","title":"Produce Mean and Variance from Output"},{"location":"Home/about/","text":"About For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"About"},{"location":"Home/about/#about","text":"For full documentation visit mkdocs.org .","title":"About"},{"location":"Home/about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Home/about/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Home/log/","text":"Changelog","title":"Changelog"},{"location":"Home/log/#changelog","text":"","title":"Changelog"},{"location":"Home/start/","text":"Getting Started Installation Clone repository or download ZIP In RStudio: File > Open project > /rit-main In RStudio Console: install.packages(\"devtools\") library(\"devtools\") load_all(export_all = FALSE) Demo Visit demo/ directory to find example workflows for each module.","title":"Getting Started"},{"location":"Home/start/#getting-started","text":"","title":"Getting Started"},{"location":"Home/start/#installation","text":"Clone repository or download ZIP In RStudio: File > Open project > /rit-main In RStudio Console: install.packages(\"devtools\") library(\"devtools\") load_all(export_all = FALSE)","title":"Installation"},{"location":"Home/start/#demo","text":"Visit demo/ directory to find example workflows for each module.","title":"Demo"},{"location":"Policy%20Valuation/cashflow/","text":"Simulating Cashflows Simulate cash flows using Monte-Carlo methods for a given policy. Function will use generated mortality, health state and economic variables to generate cashflows for n different pathways. This can be used either directly for calculations, or passed into the value_policy function for pricing statistics. Note For each policy, the benefit paid at each time period is defined as below: Account Based Pension : If the policyholder is alive, pays the inflation-adjusted expense. If the benefit exceeds the remaining balance, the remaining balance is paid. Otherwise, no benefit is paid. Life Annuity : If the deferment period has elapsed and policyholder is alive, pays benefit after flat-rate increase adjustment. Otherwise, no benefit is paid. Care Annuity : If policyholder is alive or minimum guaranteed period is still active, pays sum of all benefits a policyholder is eligible for under LTC after flat-rate increase adjustment. Otherwise, no benefit is paid. Variable Annuity : If policyholder is alive, pays benefit of the maximum withdrawal amount permissible under the contract. If the benefit exceeds the remaining balance, the remaining balance is paid. Otherwise, no benefit is paid. Pooled Annuity : If the policyholder is alive, pays benefit after factoring mortality experience adjustment \\((p_{x+t}/p_{x+t}^*)\\) and interest rate adjustment \\((1+r_{x+t}^*)/(1+r_{x+t})\\) . Otherwise, no benefit is paid. Reverse Mortgage : If the policyholder dies during the time period, pays the surplus of the loan value deducted by house value after adjusting for cost-of-sale. If the surplus is negative or policyholder doesn't die during period, no benefit is paid. simulate_cf(policy, age, sex, seed, n) Parameters: policy : Policy object Policy object generated from create_policy function (see Creating Policy Object ) age : numeric Initial age of policyholder in years sex : character sex = \"F\" (female), \"M\" (male) seed : numeric Random seed used for RNG n : numeric Number of paths to simulate (Monte-Carlo method) state : matrix Matrix of health states for \\(n\\) pathways over \\(m\\) periods (see Health State / Mortality ) econ_var : list List of matrices for each economic variables required by the chosen policy, these include: - $sdf: stochastic discount factor -> required by All Policies - $infla: inflation index -> required by Account Based Pension - $stock: stock price -> required by Account Based Pension, Pooled Annuity, Variable Annuity - $zcp3m: zero-coupon bond yield (3-month) -> required by Reverse Mortgage - $house: house price -> required by Reverse Mortgage (see Economic Scenario Generator for example implementation) Returns: SimCashflow object Usage: ap <- create_policy_AP ( 400000 , 60000 ) cf <- simulate_cf ( policy = ap , age = 65 , sex = \"M\" , n = 1000 ) Note state & econ_var use \\(n \u00d7 m\\) matrices, where \\(n\\) is the number of simulated paths and \\(m\\) is the number of periods. Any periodicity can be used as long as all matrices are consistent, i.e. each time-step can represent a month, year, or other length (simulation defaults to annual period). Note Economic variables needed by each policy: Account Based Pension : requires stochastic discount factors ( $sdf ), inflation rate ( $infla ) & investment return ( $stock ). Life Annuity : requires stochastic discount factors ( $sdf ). Care Annuity : requires stochastic discount factors ( $sdf ). Variable Annuity : requires stochastic discount factors ( $sdf ), investment return ( $stock ). Pooled Annuity : requires stochastic discount factors ( $sdf ), investment return ( $stock ). Reverse Mortgage : requires stochastic discount factors ( $sdf ), 3-month zero-coupon bond yield ( $zcp3m ) & change in house price ( $house ). SimCashflow Attributes: cf : Matrix Simulated cashflows for each pathway at every time step sdf : Matrix Stochastic discount factors for each pathway at every time step Note cf & sdf are \\(n \u00d7 m\\) matrices, where \\(n\\) is the number of simulated paths and \\(m\\) is the number of periods.","title":"Simulating Cashflows"},{"location":"Policy%20Valuation/cashflow/#simulating-cashflows","text":"Simulate cash flows using Monte-Carlo methods for a given policy. Function will use generated mortality, health state and economic variables to generate cashflows for n different pathways. This can be used either directly for calculations, or passed into the value_policy function for pricing statistics. Note For each policy, the benefit paid at each time period is defined as below: Account Based Pension : If the policyholder is alive, pays the inflation-adjusted expense. If the benefit exceeds the remaining balance, the remaining balance is paid. Otherwise, no benefit is paid. Life Annuity : If the deferment period has elapsed and policyholder is alive, pays benefit after flat-rate increase adjustment. Otherwise, no benefit is paid. Care Annuity : If policyholder is alive or minimum guaranteed period is still active, pays sum of all benefits a policyholder is eligible for under LTC after flat-rate increase adjustment. Otherwise, no benefit is paid. Variable Annuity : If policyholder is alive, pays benefit of the maximum withdrawal amount permissible under the contract. If the benefit exceeds the remaining balance, the remaining balance is paid. Otherwise, no benefit is paid. Pooled Annuity : If the policyholder is alive, pays benefit after factoring mortality experience adjustment \\((p_{x+t}/p_{x+t}^*)\\) and interest rate adjustment \\((1+r_{x+t}^*)/(1+r_{x+t})\\) . Otherwise, no benefit is paid. Reverse Mortgage : If the policyholder dies during the time period, pays the surplus of the loan value deducted by house value after adjusting for cost-of-sale. If the surplus is negative or policyholder doesn't die during period, no benefit is paid. simulate_cf(policy, age, sex, seed, n) Parameters: policy : Policy object Policy object generated from create_policy function (see Creating Policy Object ) age : numeric Initial age of policyholder in years sex : character sex = \"F\" (female), \"M\" (male) seed : numeric Random seed used for RNG n : numeric Number of paths to simulate (Monte-Carlo method) state : matrix Matrix of health states for \\(n\\) pathways over \\(m\\) periods (see Health State / Mortality ) econ_var : list List of matrices for each economic variables required by the chosen policy, these include: - $sdf: stochastic discount factor -> required by All Policies - $infla: inflation index -> required by Account Based Pension - $stock: stock price -> required by Account Based Pension, Pooled Annuity, Variable Annuity - $zcp3m: zero-coupon bond yield (3-month) -> required by Reverse Mortgage - $house: house price -> required by Reverse Mortgage (see Economic Scenario Generator for example implementation) Returns: SimCashflow object Usage: ap <- create_policy_AP ( 400000 , 60000 ) cf <- simulate_cf ( policy = ap , age = 65 , sex = \"M\" , n = 1000 ) Note state & econ_var use \\(n \u00d7 m\\) matrices, where \\(n\\) is the number of simulated paths and \\(m\\) is the number of periods. Any periodicity can be used as long as all matrices are consistent, i.e. each time-step can represent a month, year, or other length (simulation defaults to annual period). Note Economic variables needed by each policy: Account Based Pension : requires stochastic discount factors ( $sdf ), inflation rate ( $infla ) & investment return ( $stock ). Life Annuity : requires stochastic discount factors ( $sdf ). Care Annuity : requires stochastic discount factors ( $sdf ). Variable Annuity : requires stochastic discount factors ( $sdf ), investment return ( $stock ). Pooled Annuity : requires stochastic discount factors ( $sdf ), investment return ( $stock ). Reverse Mortgage : requires stochastic discount factors ( $sdf ), 3-month zero-coupon bond yield ( $zcp3m ) & change in house price ( $house ). SimCashflow Attributes: cf : Matrix Simulated cashflows for each pathway at every time step sdf : Matrix Stochastic discount factors for each pathway at every time step Note cf & sdf are \\(n \u00d7 m\\) matrices, where \\(n\\) is the number of simulated paths and \\(m\\) is the number of periods.","title":"Simulating Cashflows"},{"location":"Policy%20Valuation/overview/","text":"Overview This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products. Retirement products include: Account-based pensions Life annuities Deferred life annuities Pooled annuities Long-term care insurance Care annuities Variable annuities with GMWB Reverse mortgages with NNEG Risk-adjusted expected cash flows are computed, and prices are determined based on relevant assumptions. Models use Australian data for Australian applications. The module includes government age pension and aged care based on current means-testing.","title":"Overview"},{"location":"Policy%20Valuation/overview/#overview","text":"This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products. Retirement products include: Account-based pensions Life annuities Deferred life annuities Pooled annuities Long-term care insurance Care annuities Variable annuities with GMWB Reverse mortgages with NNEG Risk-adjusted expected cash flows are computed, and prices are determined based on relevant assumptions. Models use Australian data for Australian applications. The module includes government age pension and aged care based on current means-testing.","title":"Overview"},{"location":"Policy%20Valuation/policy/","text":"Creating Policy Object To begin, we need to initialise a policy object which contains all relevant parameters describing the policy. Functions create_policy_AP - Account Based Pension create_policy_RM - Reverse Mortgage create_policy_LA - Life Annuity create_policy_PA - Pooled Annuity create_policy_CA - Care Annuity (LTC) create_policy_VA - Variable Annuity (GMWB) Account Based Pension create_policy_AP(balance, expenses) Parameters: balance : numeric Initial balance of Pension account expenses : numeric Initial yearly expenses for policyholder Returns: Policy object Usage: ap <- create_policy_AP ( 400000 , 60000 ) Reverse Mortgage (NNEG) create_policy_RM(value, LVR, trans_cost, margin) Parameters: value : numeric Initial value of property LVR : numeric Loan to Value ratio for PH trans_cost : numeric Transaction cost associated with sale margin : numeric Lending margin Returns: Policy object Usage: rm <- create_policy_RM ( 100000 , 0.4 , 0.01 , 0.05 ) Life Annuity create_policy_LA(benefit, defer = 0, increase = 0) Parameters: benefit : numeric Annual benefit for policy defer : numeric (Optional) Deferment period of policy increase : numeric (Optional) Annual rate of increase for policy Returns: Policy object Usage: la <- create_policy_LA ( 60000 , 5 , 0.04 , 0.05 ) Care Annuity (LTC) Note Care annuities are evaluated based on the 3-State or 5-State model outlined in the Health State module . Parameters should be vectors of length 2 or 4 (as no benefits paid whilst PH is dead, policies are only characterized by remaining states). create_policy_CA(benefit, increase, min) Parameters: benefit : vector Annual benefit for each policy increase : vector Annual rate of increase for each policy min : vector Minimum guaranteed period for each policy Returns: Policy object Usage: ca <- create_policy_CA ( c ( 60000 , 1200 ), c ( 0 , 0.04 ), c ( 8 , 0 ), c ( 0.04 , 0.05 )) Pooled Annuity create_policy_PA(benefit, size, interest) Parameters: benefit : numeric Initial annual benefit for policy size : numeric Size of pool interest : numeric Assumed investment earnings rate (flat) Returns: Policy object Usage: pa <- create_policy_PA ( 60000 , 1000 , 0.04 , 0.05 ) Variable Annuity (GMWB) create_policy_VA(value, length, prop, g_fee) Parameters: value : numeric Initial Account value (single upfront premium) length : numeric Length of contract (in years) prop : numeric Proportion of the premium that can be withdrawn annually g_fee : numeric Continuous guarantee fees for GMWB Returns: Policy object Usage: va <- create_policy_VA ( 100000 , 40 , 0.4 , 0.02 )","title":"Creating Policy Object"},{"location":"Policy%20Valuation/policy/#creating-policy-object","text":"To begin, we need to initialise a policy object which contains all relevant parameters describing the policy.","title":"Creating Policy Object"},{"location":"Policy%20Valuation/policy/#functions","text":"create_policy_AP - Account Based Pension create_policy_RM - Reverse Mortgage create_policy_LA - Life Annuity create_policy_PA - Pooled Annuity create_policy_CA - Care Annuity (LTC) create_policy_VA - Variable Annuity (GMWB)","title":"Functions"},{"location":"Policy%20Valuation/policy/#account-based-pension","text":"create_policy_AP(balance, expenses) Parameters: balance : numeric Initial balance of Pension account expenses : numeric Initial yearly expenses for policyholder Returns: Policy object Usage: ap <- create_policy_AP ( 400000 , 60000 )","title":"Account Based Pension"},{"location":"Policy%20Valuation/policy/#reverse-mortgage-nneg","text":"create_policy_RM(value, LVR, trans_cost, margin) Parameters: value : numeric Initial value of property LVR : numeric Loan to Value ratio for PH trans_cost : numeric Transaction cost associated with sale margin : numeric Lending margin Returns: Policy object Usage: rm <- create_policy_RM ( 100000 , 0.4 , 0.01 , 0.05 )","title":"Reverse Mortgage (NNEG)"},{"location":"Policy%20Valuation/policy/#life-annuity","text":"create_policy_LA(benefit, defer = 0, increase = 0) Parameters: benefit : numeric Annual benefit for policy defer : numeric (Optional) Deferment period of policy increase : numeric (Optional) Annual rate of increase for policy Returns: Policy object Usage: la <- create_policy_LA ( 60000 , 5 , 0.04 , 0.05 )","title":"Life Annuity"},{"location":"Policy%20Valuation/policy/#care-annuity-ltc","text":"Note Care annuities are evaluated based on the 3-State or 5-State model outlined in the Health State module . Parameters should be vectors of length 2 or 4 (as no benefits paid whilst PH is dead, policies are only characterized by remaining states). create_policy_CA(benefit, increase, min) Parameters: benefit : vector Annual benefit for each policy increase : vector Annual rate of increase for each policy min : vector Minimum guaranteed period for each policy Returns: Policy object Usage: ca <- create_policy_CA ( c ( 60000 , 1200 ), c ( 0 , 0.04 ), c ( 8 , 0 ), c ( 0.04 , 0.05 ))","title":"Care Annuity (LTC)"},{"location":"Policy%20Valuation/policy/#pooled-annuity","text":"create_policy_PA(benefit, size, interest) Parameters: benefit : numeric Initial annual benefit for policy size : numeric Size of pool interest : numeric Assumed investment earnings rate (flat) Returns: Policy object Usage: pa <- create_policy_PA ( 60000 , 1000 , 0.04 , 0.05 )","title":"Pooled Annuity"},{"location":"Policy%20Valuation/policy/#variable-annuity-gmwb","text":"create_policy_VA(value, length, prop, g_fee) Parameters: value : numeric Initial Account value (single upfront premium) length : numeric Length of contract (in years) prop : numeric Proportion of the premium that can be withdrawn annually g_fee : numeric Continuous guarantee fees for GMWB Returns: Policy object Usage: va <- create_policy_VA ( 100000 , 40 , 0.4 , 0.02 )","title":"Variable Annuity (GMWB)"},{"location":"Policy%20Valuation/pricing/","text":"Valuation Conducts valuation of a given policy, providing summary statistic & plots on the total discounted value of all cashflows received by each pathway. value_policy(policy, cashflows, seed) Parameters: policy : Policy object Policy object generated from create_policy function (see Creating Policy Object ) cashflows : Matrix Matrix of cashflows generated from simulate_cf function (see Simulating Cashflows ) seed : numeric Random seed used for random sampling Returns: PolStats object Usage: > ap <- create_policy_AP ( 400000 , 60000 ) > cf <- simulate_cf ( policy = ap , age = 65 , sex = \"M\" , n = 1000 ) > v <- value_policy ( ap , cf ) ========= Policy Details ========= Type : Account Based Policy ---------------------------------- Balance : 4e+05 Expense : 60000 ======= Summary Statistics ======= Mean : $ 343 , 583.95 Std Dev : $ 39 , 612.09 ---------------------------------- Minimum : $ 55 , 283.93 Maximum : $ 590 , 965.62 ---------------------------------- P_0.25 : $ 316 , 733.50 P_0.50 : $ 339 , 143.08 P_0.75 : $ 365 , 797.98 P_0.95 : $ 413 , 909.46 P_0.99 : $ 455 , 971.51 ---------------------------------- Skewness : 0.44 Kurtosis : 5.47 ================================== PolStats Attributes: paths : Vector Valuation of individual cashflows by path stats : List Summary statistics of discounted cashflow conv : Plot Convergence plot of simulation using random sampling dist : Plot Distribution plot of present value by path scat : Plot Scatter plot of present value by path","title":"Valuation"},{"location":"Policy%20Valuation/pricing/#valuation","text":"Conducts valuation of a given policy, providing summary statistic & plots on the total discounted value of all cashflows received by each pathway. value_policy(policy, cashflows, seed) Parameters: policy : Policy object Policy object generated from create_policy function (see Creating Policy Object ) cashflows : Matrix Matrix of cashflows generated from simulate_cf function (see Simulating Cashflows ) seed : numeric Random seed used for random sampling Returns: PolStats object Usage: > ap <- create_policy_AP ( 400000 , 60000 ) > cf <- simulate_cf ( policy = ap , age = 65 , sex = \"M\" , n = 1000 ) > v <- value_policy ( ap , cf ) ========= Policy Details ========= Type : Account Based Policy ---------------------------------- Balance : 4e+05 Expense : 60000 ======= Summary Statistics ======= Mean : $ 343 , 583.95 Std Dev : $ 39 , 612.09 ---------------------------------- Minimum : $ 55 , 283.93 Maximum : $ 590 , 965.62 ---------------------------------- P_0.25 : $ 316 , 733.50 P_0.50 : $ 339 , 143.08 P_0.75 : $ 365 , 797.98 P_0.95 : $ 413 , 909.46 P_0.99 : $ 455 , 971.51 ---------------------------------- Skewness : 0.44 Kurtosis : 5.47 ================================== PolStats Attributes: paths : Vector Valuation of individual cashflows by path stats : List Summary statistics of discounted cashflow conv : Plot Convergence plot of simulation using random sampling dist : Plot Distribution plot of present value by path scat : Plot Scatter plot of present value by path","title":"Valuation"},{"location":"Policy%20Valuation/workflow/","text":"Workflow Example Default Behaviour # Account-Based Pension ap <- create_policy_AP ( 1000000 , 50000 ) cf_ap <- simulate_cf ( ap ) val_ap <- value_policy ( ap , cf_ap ) # Life Annuity la <- create_policy_LA ( 60000 , 5 , 0 , 0.01 ) cf_la <- simulate_cf ( la ) val_la <- value_policy ( la , cf_la ) # Pooled Annuity pa <- create_policy_PA ( 60000 , 10000 , 0.05 , 0.01 ) cf_pa <- simulate_cf ( pa ) val_pa <- value_policy ( pa , cf_pa ) # Care Annuity ca <- create_policy_CA ( c ( 60000 , 1200 ), c ( 0 , 0.04 ), c ( 5 , 0 ), c ( 0.04 , 0.01 )) cf_ca <- simulate_cf ( ca ) val_ca <- value_policy ( ca , cf_ca ) # Reverse Mortgage rm <- create_policy_RM ( 600000 , 0.64 , 0.01 , 0.04 ) cf_rm <- simulate_cf ( rm ) val_rm <- value_policy ( rm , cf_rm ) # Variable Annuity (GMWB) va <- create_policy_VA ( 1000000 , 30 , 0.1 , 0.01 ) cf_va <- simulate_cf ( va ) val_va <- value_policy ( va , cf_va ) Customised Behaviour Example 1: Life annuity where n'th policyholder dies in year n construct_state_matrix <- function ( ages_at_death , max_years ) { n_paths <- length ( ages_at_death ) # Create matrix with all entries = -1 (i.e. PH is dead) state <- matrix ( rep ( -1 , n_paths * max_years ), nrow = n_paths , ncol = max_years , byrow = TRUE ) for ( i in seq ( 1 , n_paths )) { # Set all entries in i'th row prior to death as 0 (i.e. PH is alive) death_yr <- ages_at_death [ i ] state [ i , 1 : death_yr ] <- rep ( 0 , death_yr ) } return ( state ) } # Construct state matrix ages_at_death = seq ( 1 , 100 ) state <- construct_state_matrix ( ages_at_death , max_years = 100 ) # Create list of relevant economic variables sdf <- matrix ( rep ( 1.06 , N_PATHS * MAX_YEARS ), nrow = 100 , ncol = 100 , byrow = TRUE ) econ_var <- list ( sdf = sdf ) la <- create_policy_LA ( 1 , defer = 0 , increase = 0 ) cf_la <- simulate_cf ( la , n = 100 , state = state , econ_var = econ_var ) val_la <- value_policy ( la , cf_la ) Example 2: Life annuity using life tables from 'lifecontingencies' construct_state_matrix <- function ( ages_at_death , max_years ) { n_paths <- length ( ages_at_death ) # Create matrix with all entries = -1 (i.e. PH is dead) state <- matrix ( rep ( -1 , n_paths * max_years ), nrow = n_paths , ncol = max_years , byrow = TRUE ) for ( i in seq ( 1 , n_paths )) { # Set all entries in i'th row prior to death as 0 (i.e. PH is alive) death_yr <- ages_at_death [ i ] state [ i , 1 : death_yr ] <- rep ( 0 , death_yr ) } return ( state ) } get_ages_at_death <- function ( surv_probs , max_years , n_paths ) { ages_at_death <- c () for ( i in seq ( 1 , n_paths )) { p <- stats :: runif ( length ( surv_probs )) lv <- min ( which (( p > surv_probs ) == TRUE )) ages_at_death <- c ( ages_at_death , lv ) } return ( ages_at_death ) } get_px_from_lx <- function ( lx ) { px <- lx px [ 1 ] <- 1 for ( i in seq ( 2 , length ( lx ) - 1 )) { px [ i ] <- 1 - ( lx [ i ] - lx [ i +1 ]) / lx [ i ] } px [ length ( lx )] <- 0 return ( px ) } library ( lifecontingencies ); data ( soaLt ); initial_age <- 65 soa08Act <- with ( soaLt , new ( \"actuarialtable\" , interest = 0.06 , x = x , lx = Ix , name = \"SOA2008\" )) lx08 <- soa08Act @ lx [ initial_age + 1 : length ( soa08Act @ lx )] # Extract survival probabilities from soa0xAct surv <- extract_px_from_lx ( lx08 ) # Simulate ages at death based on survival probabilities death_ages <- get_ages_at_death ( surv , 100 , 100 ) # Construct state matrix state <- construct_state_matrix ( death_ages , max_years = 100 ) la <- create_policy_LA ( 1 , defer = 0 , increase = 0 ) cf_la <- simulate_cf ( la , n = 100 , state = state ) val_la <- value_policy ( la , cf_la )","title":"Workflow Example"},{"location":"Policy%20Valuation/workflow/#workflow-example","text":"","title":"Workflow Example"},{"location":"Policy%20Valuation/workflow/#default-behaviour","text":"# Account-Based Pension ap <- create_policy_AP ( 1000000 , 50000 ) cf_ap <- simulate_cf ( ap ) val_ap <- value_policy ( ap , cf_ap ) # Life Annuity la <- create_policy_LA ( 60000 , 5 , 0 , 0.01 ) cf_la <- simulate_cf ( la ) val_la <- value_policy ( la , cf_la ) # Pooled Annuity pa <- create_policy_PA ( 60000 , 10000 , 0.05 , 0.01 ) cf_pa <- simulate_cf ( pa ) val_pa <- value_policy ( pa , cf_pa ) # Care Annuity ca <- create_policy_CA ( c ( 60000 , 1200 ), c ( 0 , 0.04 ), c ( 5 , 0 ), c ( 0.04 , 0.01 )) cf_ca <- simulate_cf ( ca ) val_ca <- value_policy ( ca , cf_ca ) # Reverse Mortgage rm <- create_policy_RM ( 600000 , 0.64 , 0.01 , 0.04 ) cf_rm <- simulate_cf ( rm ) val_rm <- value_policy ( rm , cf_rm ) # Variable Annuity (GMWB) va <- create_policy_VA ( 1000000 , 30 , 0.1 , 0.01 ) cf_va <- simulate_cf ( va ) val_va <- value_policy ( va , cf_va )","title":"Default Behaviour"},{"location":"Policy%20Valuation/workflow/#customised-behaviour","text":"","title":"Customised Behaviour"},{"location":"Policy%20Valuation/workflow/#example-1-life-annuity-where-nth-policyholder-dies-in-year-n","text":"construct_state_matrix <- function ( ages_at_death , max_years ) { n_paths <- length ( ages_at_death ) # Create matrix with all entries = -1 (i.e. PH is dead) state <- matrix ( rep ( -1 , n_paths * max_years ), nrow = n_paths , ncol = max_years , byrow = TRUE ) for ( i in seq ( 1 , n_paths )) { # Set all entries in i'th row prior to death as 0 (i.e. PH is alive) death_yr <- ages_at_death [ i ] state [ i , 1 : death_yr ] <- rep ( 0 , death_yr ) } return ( state ) } # Construct state matrix ages_at_death = seq ( 1 , 100 ) state <- construct_state_matrix ( ages_at_death , max_years = 100 ) # Create list of relevant economic variables sdf <- matrix ( rep ( 1.06 , N_PATHS * MAX_YEARS ), nrow = 100 , ncol = 100 , byrow = TRUE ) econ_var <- list ( sdf = sdf ) la <- create_policy_LA ( 1 , defer = 0 , increase = 0 ) cf_la <- simulate_cf ( la , n = 100 , state = state , econ_var = econ_var ) val_la <- value_policy ( la , cf_la )","title":"Example 1: Life annuity where n'th policyholder dies in year n"},{"location":"Policy%20Valuation/workflow/#example-2-life-annuity-using-life-tables-from-lifecontingencies","text":"construct_state_matrix <- function ( ages_at_death , max_years ) { n_paths <- length ( ages_at_death ) # Create matrix with all entries = -1 (i.e. PH is dead) state <- matrix ( rep ( -1 , n_paths * max_years ), nrow = n_paths , ncol = max_years , byrow = TRUE ) for ( i in seq ( 1 , n_paths )) { # Set all entries in i'th row prior to death as 0 (i.e. PH is alive) death_yr <- ages_at_death [ i ] state [ i , 1 : death_yr ] <- rep ( 0 , death_yr ) } return ( state ) } get_ages_at_death <- function ( surv_probs , max_years , n_paths ) { ages_at_death <- c () for ( i in seq ( 1 , n_paths )) { p <- stats :: runif ( length ( surv_probs )) lv <- min ( which (( p > surv_probs ) == TRUE )) ages_at_death <- c ( ages_at_death , lv ) } return ( ages_at_death ) } get_px_from_lx <- function ( lx ) { px <- lx px [ 1 ] <- 1 for ( i in seq ( 2 , length ( lx ) - 1 )) { px [ i ] <- 1 - ( lx [ i ] - lx [ i +1 ]) / lx [ i ] } px [ length ( lx )] <- 0 return ( px ) } library ( lifecontingencies ); data ( soaLt ); initial_age <- 65 soa08Act <- with ( soaLt , new ( \"actuarialtable\" , interest = 0.06 , x = x , lx = Ix , name = \"SOA2008\" )) lx08 <- soa08Act @ lx [ initial_age + 1 : length ( soa08Act @ lx )] # Extract survival probabilities from soa0xAct surv <- extract_px_from_lx ( lx08 ) # Simulate ages at death based on survival probabilities death_ages <- get_ages_at_death ( surv , 100 , 100 ) # Construct state matrix state <- construct_state_matrix ( death_ages , max_years = 100 ) la <- create_policy_LA ( 1 , defer = 0 , increase = 0 ) cf_la <- simulate_cf ( la , n = 100 , state = state ) val_la <- value_policy ( la , cf_la )","title":"Example 2: Life annuity using life tables from 'lifecontingencies'"}]}