{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Retirement Income Toolkit Toolkit of R modules for researchers to use in modeling retirement and age care risks, simulating cash flows for a range of retirement and long-term care products including Australian government support for Age Pensions and Aged Care based on means-testing, pricing and quantifying risk for a range of finance and insurance products to finance retirement and aged care risks. Toolkit Modules Aggregate Mortality Simulation This module will produce future cohort mortality scenarios for a specified age group for input into cash flow simulation and valuation modules. Input will be the model selected and parameter estimates derived from other available R packages (StMoMo). A range of aggregate mortality models will be included so users can select the preferred model: Lee-Carter Age-Period-Cohort Renshaw-Haberman, CBD Gaussian affine (2 and 3-factor models) Output will include: Future cohort mortality rates and survival probability curves at future dates for a specified age cohort (starting from age 50 to age 110) Initial age risk-adjusted survival probabilities using specified risk adjustment methods (with input parameters for risk adjustment) Sharpe ratio Wang transform Price of risk for factor models Distributions of future lifetimes along (with summary statistics including expected future lifetime, standard deviation of future lifetime, impact of uncertainty in mortality rates versus expected mortality rates and survival probabilities) Health State Modeling This module will produce transition probabilities for health state and functional disability models for a specified initial age (from 50 to 65 up to age 110) and health state based on the calibrated parametrization of models. Models to include static models, improvement trends in transition rates and stochastic transition rates (latent factor). Models will include functional disability based on: Various ADL\u2019s (2+, 3+, cognitive decline) with recovery Joint health status Disability states based on core activities for Australian applications Output will include: Probability transition matrices for different starting ages derived from transition rates, with trends Expected transition rates and simulated future transition rates for stochastic simulations Models will be included to forecast the Australian prevalence of disabled populations based on functional disability models. Economic Scenario Generator Outputs are joint simulated scenarios over specified horizons (age 50 to 110 \u2013 60 years) for economic variables, distributions of simulated variables at differing horizons (10 years, 20 years, 50 years, 60 years). The R code will input the parameters for a selected model (VAR) and generate: Simulated (correlated) paths for all the variables to use in cash flow modeling + computing expected values Valuation of cash flows in the cash flow module Distributions of the variables at different horizons \u2013 5 years, 10 years, 30 years Distributions of values of assets in real terms (deflated by GDP, CPI) over different horizons to show the impact of real returns and uncertainty in returns on other assets (equities, cash, housing, rolling bonds). Cash Flow Simulation + Pricing This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products. Retirement products include: Account-based pensions Life annuities Deferred life annuities Pooled annuities Long-term care insurance Care annuities Variable annuities with GMWB Reverse mortgages with NNEG Risk-adjusted expected cash flows are computed, and prices are determined based on specified assumptions. Models use Australian data for Australian applications initially. The module includes government age pension and aged care based on current means-testing.","title":"Home"},{"location":"#retirement-income-toolkit","text":"Toolkit of R modules for researchers to use in modeling retirement and age care risks, simulating cash flows for a range of retirement and long-term care products including Australian government support for Age Pensions and Aged Care based on means-testing, pricing and quantifying risk for a range of finance and insurance products to finance retirement and aged care risks.","title":"Retirement Income Toolkit"},{"location":"#toolkit-modules","text":"","title":"Toolkit Modules"},{"location":"#aggregate-mortality-simulation","text":"This module will produce future cohort mortality scenarios for a specified age group for input into cash flow simulation and valuation modules. Input will be the model selected and parameter estimates derived from other available R packages (StMoMo). A range of aggregate mortality models will be included so users can select the preferred model: Lee-Carter Age-Period-Cohort Renshaw-Haberman, CBD Gaussian affine (2 and 3-factor models) Output will include: Future cohort mortality rates and survival probability curves at future dates for a specified age cohort (starting from age 50 to age 110) Initial age risk-adjusted survival probabilities using specified risk adjustment methods (with input parameters for risk adjustment) Sharpe ratio Wang transform Price of risk for factor models Distributions of future lifetimes along (with summary statistics including expected future lifetime, standard deviation of future lifetime, impact of uncertainty in mortality rates versus expected mortality rates and survival probabilities)","title":"Aggregate Mortality Simulation"},{"location":"#health-state-modeling","text":"This module will produce transition probabilities for health state and functional disability models for a specified initial age (from 50 to 65 up to age 110) and health state based on the calibrated parametrization of models. Models to include static models, improvement trends in transition rates and stochastic transition rates (latent factor). Models will include functional disability based on: Various ADL\u2019s (2+, 3+, cognitive decline) with recovery Joint health status Disability states based on core activities for Australian applications Output will include: Probability transition matrices for different starting ages derived from transition rates, with trends Expected transition rates and simulated future transition rates for stochastic simulations Models will be included to forecast the Australian prevalence of disabled populations based on functional disability models.","title":"Health State Modeling"},{"location":"#economic-scenario-generator","text":"Outputs are joint simulated scenarios over specified horizons (age 50 to 110 \u2013 60 years) for economic variables, distributions of simulated variables at differing horizons (10 years, 20 years, 50 years, 60 years). The R code will input the parameters for a selected model (VAR) and generate: Simulated (correlated) paths for all the variables to use in cash flow modeling + computing expected values Valuation of cash flows in the cash flow module Distributions of the variables at different horizons \u2013 5 years, 10 years, 30 years Distributions of values of assets in real terms (deflated by GDP, CPI) over different horizons to show the impact of real returns and uncertainty in returns on other assets (equities, cash, housing, rolling bonds).","title":"Economic Scenario Generator"},{"location":"#cash-flow-simulation-pricing","text":"This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products. Retirement products include: Account-based pensions Life annuities Deferred life annuities Pooled annuities Long-term care insurance Care annuities Variable annuities with GMWB Reverse mortgages with NNEG Risk-adjusted expected cash flows are computed, and prices are determined based on specified assumptions. Models use Australian data for Australian applications initially. The module includes government age pension and aged care based on current means-testing.","title":"Cash Flow Simulation + Pricing"},{"location":"Aggregate%20Mortality/overview/","text":"Overview There is a popular package in R, StMoMo, that is used for stochastic mortality modelling. It includes functions that fit a wide range of age-period-cohort models such as the Lee-Carter, Cairns-Blake-Dowd models and many others. These are typically used to forecast and simulate future mortality rates. The aggregate mortality module extends upon the StMoMo package by introducing the following functionalities: Adding methods for more accurate mortality estimation at older ages (rate completion) Transforming survival functions from the real world to the risk-free probability measure Distribution and quantile functions of a survival function Simulation plots of the survival function and expected curtate future lifetime for a cohort These functions will allow for more accurate mortality studies at older ages (90+) and the pricing of a diverse range of insurance products. This module should be used in tandem with the StMoMo package. Namely, the inputs of this module will usually be the mortality rates outputted by the StMoMo package. A general overview of the module and the sequence of function executions can be visualised by the flowchart below:","title":"Overview"},{"location":"Aggregate%20Mortality/overview/#overview","text":"There is a popular package in R, StMoMo, that is used for stochastic mortality modelling. It includes functions that fit a wide range of age-period-cohort models such as the Lee-Carter, Cairns-Blake-Dowd models and many others. These are typically used to forecast and simulate future mortality rates. The aggregate mortality module extends upon the StMoMo package by introducing the following functionalities: Adding methods for more accurate mortality estimation at older ages (rate completion) Transforming survival functions from the real world to the risk-free probability measure Distribution and quantile functions of a survival function Simulation plots of the survival function and expected curtate future lifetime for a cohort These functions will allow for more accurate mortality studies at older ages (90+) and the pricing of a diverse range of insurance products. This module should be used in tandem with the StMoMo package. Namely, the inputs of this module will usually be the mortality rates outputted by the StMoMo package. A general overview of the module and the sequence of function executions can be visualised by the flowchart below:","title":"Overview"},{"location":"Aggregate%20Mortality/period_cohort/","text":"Period and Cohort Rates All of the analysis performed after mortality rate completion, such as survival function creation and transformation, output of summary statistics can be performed on both period and cohort mortality rates. In fact, mortality rates are often presented in a period format but cohort rates are more suitable for the pricing of insurance products. Thus, this module introduces 2 helper functions to convert between period and cohort mortality rates. Period to Cohort Rates period2cohort <- function(period_rates, ages, init_age = NULL) Parameters: period_rates : matrix/array period mortality rates with age rows, calendar year columns (and simulation number 3rd dimension) ages : vector vector of ages for period_rates init_age : numeric initial age of cohort (default smallest age) Returns: matrix/array of cohort mortality rates with age rows, cohort columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' period_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 # convert to rates for cohort aged 55 cohort_rates_55 <- period2cohort ( period_rates , ages , init_age = 55 ) Cohort to Period Rates cohort2period <- function(cohort_rates) Parameters: cohort_rates : matrix/array cohort mortality rates with age rows, cohort columns (and simulation number 3rd dimension) Returns: matrix/array of period mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the Kannisto completion method on male mortality rates # from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) # suppose these are rates for cohort starting at age 60 cohort_rates_60 <- completed_rates [ as.character ( 60 : 130 ), ] period_rates <- cohort2period ( cohort_rates_60 )","title":"Period and Cohort Rates"},{"location":"Aggregate%20Mortality/period_cohort/#period-and-cohort-rates","text":"All of the analysis performed after mortality rate completion, such as survival function creation and transformation, output of summary statistics can be performed on both period and cohort mortality rates. In fact, mortality rates are often presented in a period format but cohort rates are more suitable for the pricing of insurance products. Thus, this module introduces 2 helper functions to convert between period and cohort mortality rates.","title":"Period and Cohort Rates"},{"location":"Aggregate%20Mortality/period_cohort/#period-to-cohort-rates","text":"period2cohort <- function(period_rates, ages, init_age = NULL) Parameters: period_rates : matrix/array period mortality rates with age rows, calendar year columns (and simulation number 3rd dimension) ages : vector vector of ages for period_rates init_age : numeric initial age of cohort (default smallest age) Returns: matrix/array of cohort mortality rates with age rows, cohort columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' period_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 # convert to rates for cohort aged 55 cohort_rates_55 <- period2cohort ( period_rates , ages , init_age = 55 )","title":"Period to Cohort Rates"},{"location":"Aggregate%20Mortality/period_cohort/#cohort-to-period-rates","text":"cohort2period <- function(cohort_rates) Parameters: cohort_rates : matrix/array cohort mortality rates with age rows, cohort columns (and simulation number 3rd dimension) Returns: matrix/array of period mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the Kannisto completion method on male mortality rates # from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) # suppose these are rates for cohort starting at age 60 cohort_rates_60 <- completed_rates [ as.character ( 60 : 130 ), ] period_rates <- cohort2period ( cohort_rates_60 )","title":"Cohort to Period Rates"},{"location":"Aggregate%20Mortality/rate_change/","text":"Mortality Rate Changing Mortality rates can be expressed in different types, such as central death rates, 1-year death probabilities and force of mortality. Different mortality rate completion methods require different types of mortality rates so this module includes a helper function to change between the types of mortality rates. We use the following notation for an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\) : \\(m_{x, y}^{(i)}\\) : central death rate \\(q_{x, y}^{(i)}\\) : 1-year death probability \\(\\mu_{x, y}^{(i)}\\) : force of mortality Implementation assumes a constant force of mortality for fractional ages, resulting in the following conversions: \\(q_{x, y}^{(i)} = 1 - e^{-\\mu_{x, y}^{(i)}}\\) \\(\\mu_{x, y}^{(i)} = m_{x, y}^{(i)}\\) \\(m_{x, y}^{(i)} = -\\log(1 - q_{x, y}^{(i)})\\) Mortality Rate Changing rate2rate <- function(rates, from, to) Parameters: rates : matrix/array mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) from : character input type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality to : character desired output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality Returns: matrix/array of converted mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' central_rates <- mortality_AUS_data $ rate $ male # convert to 1-yr death probabilities death_prob <- rate2rate ( central_rates , from = \"central\" , to = \"prob\" )","title":"Mortality Rate Changing"},{"location":"Aggregate%20Mortality/rate_change/#mortality-rate-changing","text":"Mortality rates can be expressed in different types, such as central death rates, 1-year death probabilities and force of mortality. Different mortality rate completion methods require different types of mortality rates so this module includes a helper function to change between the types of mortality rates. We use the following notation for an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\) : \\(m_{x, y}^{(i)}\\) : central death rate \\(q_{x, y}^{(i)}\\) : 1-year death probability \\(\\mu_{x, y}^{(i)}\\) : force of mortality Implementation assumes a constant force of mortality for fractional ages, resulting in the following conversions: \\(q_{x, y}^{(i)} = 1 - e^{-\\mu_{x, y}^{(i)}}\\) \\(\\mu_{x, y}^{(i)} = m_{x, y}^{(i)}\\) \\(m_{x, y}^{(i)} = -\\log(1 - q_{x, y}^{(i)})\\)","title":"Mortality Rate Changing"},{"location":"Aggregate%20Mortality/rate_change/#mortality-rate-changing_1","text":"rate2rate <- function(rates, from, to) Parameters: rates : matrix/array mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) from : character input type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality to : character desired output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality Returns: matrix/array of converted mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' central_rates <- mortality_AUS_data $ rate $ male # convert to 1-yr death probabilities death_prob <- rate2rate ( central_rates , from = \"central\" , to = \"prob\" )","title":"Mortality Rate Changing"},{"location":"Aggregate%20Mortality/rate_completion/","text":"Mortality Rate Completion The StMoMo package has good accuracy with mortality calculations for younger ages. However, for older ages (>90), other methods can be applied to improve mortality estimates. This module includes functions that apply different completion methods to 'extrapolate' more accurate mortality rates at the older ages. Coale and Kisker Method The Coale and Kisker method is used to close life tables that builds upon the classical Gompertz model. As in the Gompertz Model, we use an exponential rate of mortality, but instead of it being constant, we say it declines linearly. coale_kisker(rates, ages, old_ages, type = 'central', closure_age = 130, m_end = 1, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age m_end : numeric/vector central death rate at maximum age years : vector optional numeric vector of years for rates Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 completed_rates <- coale_kisker ( AUS_male_rates , ages , old_ages , type = \"central\" ) References: Coale, Ansley J. and Kisker, Ellen E. 1990 'Defects in data on old-age mortality in the United States: New procedures for calculating schedules and life tables at the higher ages,' Asian and Pacific Population Forum , 4: 1-31 Denuit & Goderniaux Method The Denuit and Goderniaux Method is a life table closing procedure based on constrained log-quadratic regression. This is fitted with a closure constraint (max age), generally set at 130, and an inflexion constraint that makes the rate of mortality increase at older ages slow down. Smoothing can also be applied to the results using a simple geometric average on the estimates. denuit_goderniaux(rates, ages, old_ages, type = 'prob', closure_age = 130, start_fit_age = 75, smoothing = FALSE, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age start_fit_age : numeric model is fitted to ages starting from this age smoothing : logical set TRUE to apply smoothing to the completed rates years : vector optional numeric vector of years for rates Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # first convert mortality rates to death probabilties AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) completed_qx <- denuit_goderniaux ( AUS_male_qx , ages , old_ages , type = \"prob\" ) # fit on ages 80:110 instead completed_qx_from_80 <- denuit_goderniaux ( AUS_male_qx , ages , old_ages , type = \"prob\" , start_fit_age = 80 ) References: Denuit, M. and Goderniaux A., 2005 'Closing and Projecting lifetables using log-linear models', Bulletin of the Swiss Association of Actuaries p. 29-49 Kannisto Method The Kannisto model is based on the logistic model, and the constrained nature of having only 2 free parameters makes mortality projections very consistent. Hence, it is advantangeous for the purpose of making extrapolations. It fits a model on the tail end of ages where the mortality rates are more accurate. It then extrapolates this to older ages. kannisto(rates, ages, old_ages, fitted_ages, type = 'force', closure_age = 130, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for fitted_ages : vector vector of ages to fit initial model type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age years : vector optional numeric vector of years for rates Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # fit model on tail end of ages where mortality is still accurate fitted_ages <- 76 : 90 completed_rates <- kannisto ( AUS_male_rates , ages , old_ages , fitted_ages , type = \"central\" ) References: Thatcher, A.R., Kannisto, V. and Vaupel, J.W. 1998 'The force of Mortality at Ages 80 to 120', Monographs on Population Aging , Volume 5: Odense University Press Wrapper Function The completion methods above can be incorporated into a wrapper function. complete_old_age(rates, ages, old_ages, method = \"kannisto\", type = 'prob', closure_age = 130, years = NULL, ...) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for method : character 'CK' for Coale-Kisker, 'DG' for Denuit and Goderniaux, 'Kannisto' for Kannisto type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age years : vector optional numeric vector of years for rates ... additional arguments required for the chosen completion method Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # first convert mortality rates to death probabilties AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) # completing mortality rates for old ages DG_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"DG\" , type = \"prob\" ) CK_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"CK\" , type = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 )","title":"Mortality Rate Completion"},{"location":"Aggregate%20Mortality/rate_completion/#mortality-rate-completion","text":"The StMoMo package has good accuracy with mortality calculations for younger ages. However, for older ages (>90), other methods can be applied to improve mortality estimates. This module includes functions that apply different completion methods to 'extrapolate' more accurate mortality rates at the older ages.","title":"Mortality Rate Completion"},{"location":"Aggregate%20Mortality/rate_completion/#coale-and-kisker-method","text":"The Coale and Kisker method is used to close life tables that builds upon the classical Gompertz model. As in the Gompertz Model, we use an exponential rate of mortality, but instead of it being constant, we say it declines linearly. coale_kisker(rates, ages, old_ages, type = 'central', closure_age = 130, m_end = 1, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age m_end : numeric/vector central death rate at maximum age years : vector optional numeric vector of years for rates Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 completed_rates <- coale_kisker ( AUS_male_rates , ages , old_ages , type = \"central\" ) References: Coale, Ansley J. and Kisker, Ellen E. 1990 'Defects in data on old-age mortality in the United States: New procedures for calculating schedules and life tables at the higher ages,' Asian and Pacific Population Forum , 4: 1-31","title":"Coale and Kisker Method"},{"location":"Aggregate%20Mortality/rate_completion/#denuit-goderniaux-method","text":"The Denuit and Goderniaux Method is a life table closing procedure based on constrained log-quadratic regression. This is fitted with a closure constraint (max age), generally set at 130, and an inflexion constraint that makes the rate of mortality increase at older ages slow down. Smoothing can also be applied to the results using a simple geometric average on the estimates. denuit_goderniaux(rates, ages, old_ages, type = 'prob', closure_age = 130, start_fit_age = 75, smoothing = FALSE, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age start_fit_age : numeric model is fitted to ages starting from this age smoothing : logical set TRUE to apply smoothing to the completed rates years : vector optional numeric vector of years for rates Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # first convert mortality rates to death probabilties AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) completed_qx <- denuit_goderniaux ( AUS_male_qx , ages , old_ages , type = \"prob\" ) # fit on ages 80:110 instead completed_qx_from_80 <- denuit_goderniaux ( AUS_male_qx , ages , old_ages , type = \"prob\" , start_fit_age = 80 ) References: Denuit, M. and Goderniaux A., 2005 'Closing and Projecting lifetables using log-linear models', Bulletin of the Swiss Association of Actuaries p. 29-49","title":"Denuit &amp; Goderniaux Method"},{"location":"Aggregate%20Mortality/rate_completion/#kannisto-method","text":"The Kannisto model is based on the logistic model, and the constrained nature of having only 2 free parameters makes mortality projections very consistent. Hence, it is advantangeous for the purpose of making extrapolations. It fits a model on the tail end of ages where the mortality rates are more accurate. It then extrapolates this to older ages. kannisto(rates, ages, old_ages, fitted_ages, type = 'force', closure_age = 130, years = NULL) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for fitted_ages : vector vector of ages to fit initial model type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age years : vector optional numeric vector of years for rates Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # fit model on tail end of ages where mortality is still accurate fitted_ages <- 76 : 90 completed_rates <- kannisto ( AUS_male_rates , ages , old_ages , fitted_ages , type = \"central\" ) References: Thatcher, A.R., Kannisto, V. and Vaupel, J.W. 1998 'The force of Mortality at Ages 80 to 120', Monographs on Population Aging , Volume 5: Odense University Press","title":"Kannisto Method"},{"location":"Aggregate%20Mortality/rate_completion/#wrapper-function","text":"The completion methods above can be incorporated into a wrapper function. complete_old_age(rates, ages, old_ages, method = \"kannisto\", type = 'prob', closure_age = 130, years = NULL, ...) Parameters: rates : matrix/array mortality rates with age rows, calendar year columns, (simulation number 3rd dimension) ages : vector vector of ages for rates old_ages : vector vector of old ages to be completed for method : character 'CK' for Coale-Kisker, 'DG' for Denuit and Goderniaux, 'Kannisto' for Kannisto type : character input and output type of mortality rates: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality closure_age : numeric maximum age years : vector optional numeric vector of years for rates ... additional arguments required for the chosen completion method Returns: matrix/array of completed mortality rates with age rows, year columns (and simulation number 3rd dimension) Usage: # consider the male mortality rates from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 # first convert mortality rates to death probabilties AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) # completing mortality rates for old ages DG_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"DG\" , type = \"prob\" ) CK_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"CK\" , type = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 )","title":"Wrapper Function"},{"location":"Aggregate%20Mortality/rate_survival/","text":"Mortality Rate and Survival Function The age completion functions usually return mortality rates. However, part of the functionality of this module is converting the real world probability based survival function to a risk free probability measure survival function. This requires the mortality rates to be converted to survival probabilities. This functionality is covered by 2 helper functions. Mortality Rate to Survival Function rate2survival(rates, ages, from = 'prob', init_age = NULL, years = NULL) Parameters: rates : matrix/array *mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension)* ages : vector vector of ages for rates from : character type of rate to be converted from: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality init_age : numeric initial age for survival function to be calculated at (default smallest age) years : vector optional numeric vector of years for rates Returns: matrix/array of associated survival function with survival time rows, cohort/year columns (and simulation number 3rd dimension) Usage: # consider the Kannisto completion method on male mortality rates # from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) # compute survival function of an individual aged 55 all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) Survival Function to Mortality Rate survival2rate(surv, ages, to = 'prob', years = NULL) Parameters: surv : matrix/array survival function with survival time rows, cohort/year columns (and simulation number 3rd dimension) ages : vector vector of desired ages for the resulting mortality rates to : character type of rate to be converted to: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality years : vector optional numeric vector of years for surv Returns: matrix/array of associated mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # convert from P to Q measure survival function # see the section on risk neutral probability surv_func_Q <- survivalP2Q ( surv_func , method = \"wang\" , lambda = 1.5 ) # convert from survival function to mortality rates central_rates_Q <- survival2rate ( surv_func_Q , 55 : 130 , to = 'central' ) Note that transferring from survival function to rate is mainly used after converting a survival function from real world measure to risk free measure.","title":"Mortality Rate and Survival Function"},{"location":"Aggregate%20Mortality/rate_survival/#mortality-rate-and-survival-function","text":"The age completion functions usually return mortality rates. However, part of the functionality of this module is converting the real world probability based survival function to a risk free probability measure survival function. This requires the mortality rates to be converted to survival probabilities. This functionality is covered by 2 helper functions.","title":"Mortality Rate and Survival Function"},{"location":"Aggregate%20Mortality/rate_survival/#mortality-rate-to-survival-function","text":"rate2survival(rates, ages, from = 'prob', init_age = NULL, years = NULL) Parameters: rates : matrix/array *mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension)* ages : vector vector of ages for rates from : character type of rate to be converted from: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality init_age : numeric initial age for survival function to be calculated at (default smallest age) years : vector optional numeric vector of years for rates Returns: matrix/array of associated survival function with survival time rows, cohort/year columns (and simulation number 3rd dimension) Usage: # consider the Kannisto completion method on male mortality rates # from the data file 'mortality_AUS_data' AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) # compute survival function of an individual aged 55 all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 )","title":"Mortality Rate to Survival Function"},{"location":"Aggregate%20Mortality/rate_survival/#survival-function-to-mortality-rate","text":"survival2rate(surv, ages, to = 'prob', years = NULL) Parameters: surv : matrix/array survival function with survival time rows, cohort/year columns (and simulation number 3rd dimension) ages : vector vector of desired ages for the resulting mortality rates to : character type of rate to be converted to: 'central' for central death rates, 'prob' for 1 year death probabilities, 'force' for force of mortality years : vector optional numeric vector of years for surv Returns: matrix/array of associated mortality rates with age rows, cohort/year columns (and simulation number 3rd dimension) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # convert from P to Q measure survival function # see the section on risk neutral probability surv_func_Q <- survivalP2Q ( surv_func , method = \"wang\" , lambda = 1.5 ) # convert from survival function to mortality rates central_rates_Q <- survival2rate ( surv_func_Q , 55 : 130 , to = 'central' ) Note that transferring from survival function to rate is mainly used after converting a survival function from real world measure to risk free measure.","title":"Survival Function to Mortality Rate"},{"location":"Aggregate%20Mortality/risk_neutral/","text":"Risk Neutral Probability 'StMoMo' produces real world death/survival probabilities which are very useful for mortality studies. However, real world probabilities do not account for longevity risk - the financial risk that people live longer than expected and are thus not suitable for the pricing of insurance products. Hence, this module includes a function that transforms the real world (P world) survival function to a risk neutral (Q world) survival function according to a risk-neutral principle. To introduce the transformation methods used by our function, we work with a simplified notation to focus on the transformation from the P-measure to the Q-measure. Note that this applies for an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\) . Then we use the following: \\(f^P(t)\\) or \\(f^Q(t)\\) : probability density function (pdf) \\(F^P(t)\\) or \\(F^Q(t)\\) : cumulative distribution function (cdf) \\(S^P(t)\\) or \\(S^Q(t)\\) : survival function where \\(S^P(t) = 1 - F^P(t)\\) and \\(S^Q(t) = 1 - F^Q(t)\\) . The first set of transformations are survival function distortions and are as follows: Wang transform: \\(S^Q(t) = 1 - \\Phi(\\Phi^{-1}(1 - S^P(t)) - \\lambda) \\quad (\\lambda \\geq 0)\\) where \\(\\Phi(x)\\) represents the cdf of a standard Gaussian distribution. Proportional hazard transform: \\(S^Q(t) = (S^P(t))^{\\frac{1}{\\lambda}} \\quad (\\lambda \\geq 1)\\) Dual-power transform: \\(S^Q(t) = 1 - \\left(1 - S^P(t)\\right)^\\lambda \\quad (\\lambda \\geq 1)\\) Gini principle: \\(S^Q(t) = (1 + \\lambda)S^P(t) - \\lambda(S^P(t))^2 \\quad (0 \\leq \\lambda \\leq 1)\\) Denneberg's absolute deviation principle: \\(S^Q(t) = \\begin{cases} (1 + \\lambda)S^P(t), & 0 \\leq S^P(t) < 0.5 \\\\ \\lambda + (1 - \\lambda)S^P(t), & 0.5 \\leq S^P(t) \\leq 1 \\end{cases} \\quad (0 \\leq \\lambda \\leq 1)\\) Exponential transform: \\(S^Q(t) = \\frac{1 - e^{-\\lambda S^P(t)}}{1 - e^{-\\lambda}} \\quad (\\lambda > 0)\\) Logarithmic transform: \\(S^Q(t) = \\frac{\\log(1 + \\lambda S^P(t))}{\\log(1 + \\lambda)} \\quad (\\lambda > 0)\\) The remaining transformations are pdf distortions and are given by: Canonical valuation: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)}\\) Esscher transform: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\mathbb{E}[e^{\\lambda t}]} = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)}\\) We note that for the pdf distortions (univariate canonical valuation and esscher transforms), the risk-adjusted pdfs are identical. Survival Function Risk-Neutral Transformation survivalP2Q(StP, method, lambda) Parameters: StP : matrix/array survival function under P-measure with survival time rows, cohort/year columns (and simulation number 3rd dimension) method : character distortion risk measure to use \"wang\": Wang Transform \"ph\": Proportional Hazard Transform \"dp\": Dual-power Transform \"gp\": Gini Principle \"dadp\": Denneberg's Absolute Deviation Principle \"exp\": Exponential Transform \"log\": Logarithmic Transform \"canon\": Univariate Canonical Valuation \"esscher\": Esscher Transform lambda : numeric parameter associated with the distortion risk measure Returns: matrix/array of risk neutral survival function under specified Q-measure with survival time rows, cohort/year columns (and simulation number 3rd dimension) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data$rate$male ages <- mortality_AUS_data$age # 0:110 old_ages <- 91:130 fitted_ages <- 76:90 completed_rates <- complete_old_age(AUS_male_rates, ages, old_ages, method = \"kannisto\", type = \"central\", fitted_ages = fitted_ages) all_ages <- 0:130 surv_func <- rate2survival(completed_rates, ages = all_ages, from = 'central', init_age = 55) # convert from P to Q measure survival function surv_func_Q <- survivalP2Q(surv_func, method = \"wang\", lambda = 1.5)","title":"Risk Neutral Probability"},{"location":"Aggregate%20Mortality/risk_neutral/#risk-neutral-probability","text":"'StMoMo' produces real world death/survival probabilities which are very useful for mortality studies. However, real world probabilities do not account for longevity risk - the financial risk that people live longer than expected and are thus not suitable for the pricing of insurance products. Hence, this module includes a function that transforms the real world (P world) survival function to a risk neutral (Q world) survival function according to a risk-neutral principle. To introduce the transformation methods used by our function, we work with a simplified notation to focus on the transformation from the P-measure to the Q-measure. Note that this applies for an individual aged \\(x\\) in year \\(y\\) for each simulation \\(i\\) . Then we use the following: \\(f^P(t)\\) or \\(f^Q(t)\\) : probability density function (pdf) \\(F^P(t)\\) or \\(F^Q(t)\\) : cumulative distribution function (cdf) \\(S^P(t)\\) or \\(S^Q(t)\\) : survival function where \\(S^P(t) = 1 - F^P(t)\\) and \\(S^Q(t) = 1 - F^Q(t)\\) . The first set of transformations are survival function distortions and are as follows: Wang transform: \\(S^Q(t) = 1 - \\Phi(\\Phi^{-1}(1 - S^P(t)) - \\lambda) \\quad (\\lambda \\geq 0)\\) where \\(\\Phi(x)\\) represents the cdf of a standard Gaussian distribution. Proportional hazard transform: \\(S^Q(t) = (S^P(t))^{\\frac{1}{\\lambda}} \\quad (\\lambda \\geq 1)\\) Dual-power transform: \\(S^Q(t) = 1 - \\left(1 - S^P(t)\\right)^\\lambda \\quad (\\lambda \\geq 1)\\) Gini principle: \\(S^Q(t) = (1 + \\lambda)S^P(t) - \\lambda(S^P(t))^2 \\quad (0 \\leq \\lambda \\leq 1)\\) Denneberg's absolute deviation principle: \\(S^Q(t) = \\begin{cases} (1 + \\lambda)S^P(t), & 0 \\leq S^P(t) < 0.5 \\\\ \\lambda + (1 - \\lambda)S^P(t), & 0.5 \\leq S^P(t) \\leq 1 \\end{cases} \\quad (0 \\leq \\lambda \\leq 1)\\) Exponential transform: \\(S^Q(t) = \\frac{1 - e^{-\\lambda S^P(t)}}{1 - e^{-\\lambda}} \\quad (\\lambda > 0)\\) Logarithmic transform: \\(S^Q(t) = \\frac{\\log(1 + \\lambda S^P(t))}{\\log(1 + \\lambda)} \\quad (\\lambda > 0)\\) The remaining transformations are pdf distortions and are given by: Canonical valuation: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)}\\) Esscher transform: \\(f^Q(t) = \\frac{e^{\\lambda t} f^P(t)}{\\mathbb{E}[e^{\\lambda t}]} = \\frac{e^{\\lambda t} f^P(t)}{\\sum^\\infty_{s=0} e^{\\lambda s} f^P(s)}\\) We note that for the pdf distortions (univariate canonical valuation and esscher transforms), the risk-adjusted pdfs are identical.","title":"Risk Neutral Probability"},{"location":"Aggregate%20Mortality/risk_neutral/#survival-function-risk-neutral-transformation","text":"survivalP2Q(StP, method, lambda) Parameters: StP : matrix/array survival function under P-measure with survival time rows, cohort/year columns (and simulation number 3rd dimension) method : character distortion risk measure to use \"wang\": Wang Transform \"ph\": Proportional Hazard Transform \"dp\": Dual-power Transform \"gp\": Gini Principle \"dadp\": Denneberg's Absolute Deviation Principle \"exp\": Exponential Transform \"log\": Logarithmic Transform \"canon\": Univariate Canonical Valuation \"esscher\": Esscher Transform lambda : numeric parameter associated with the distortion risk measure Returns: matrix/array of risk neutral survival function under specified Q-measure with survival time rows, cohort/year columns (and simulation number 3rd dimension) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data$rate$male ages <- mortality_AUS_data$age # 0:110 old_ages <- 91:130 fitted_ages <- 76:90 completed_rates <- complete_old_age(AUS_male_rates, ages, old_ages, method = \"kannisto\", type = \"central\", fitted_ages = fitted_ages) all_ages <- 0:130 surv_func <- rate2survival(completed_rates, ages = all_ages, from = 'central', init_age = 55) # convert from P to Q measure survival function surv_func_Q <- survivalP2Q(surv_func, method = \"wang\", lambda = 1.5)","title":"Survival Function Risk-Neutral Transformation"},{"location":"Aggregate%20Mortality/simulation/","text":"Simulating Life Paths One-year death probabilities derived from previous sections can also be used to simulate life paths for a single individual or a cohort of individuals. Each individual or cohort will be alive at a specified initial age, and we sample deaths according to the one-year death probabilities given at each age. When simulating for an individual, we keep track of their dead or alive status at each age. When simulating for a cohort, we keep track of the number of people still alive at each age. Simulate Individual Life Path sim_indiv_path(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, n_sim = 10000) Parameters: init_age : numeric integer denoting initial age of individuals sex : character character denoting the gender of individuals, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for individuals starting at init_age in 2022 closure_age : numeric maximum age n_sim : numeric integer denoting number of path simulations Returns: a matrix where each row represents an individual's dead (-1) or alive (0) status across the years An example looks like: \\[\\begin{pmatrix} 0 & -1 & -1 & -1 & \\ldots & -1 \\\\ 0 & 0 & 0 & -1 & \\ldots & -1 \\\\ & & \\vdots & & & \\\\ 0 & 0 & 0 & 0 & \\ldots & -1 \\\\ 0 & 0 & -1 & -1 & \\ldots & -1 \\end{pmatrix}\\] Note that the first column of the matrix will always be 0 as everyone is alive at the initial age, and the last column will always be -1, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate life paths for females starting at age 60 sim_indiv_path ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_indiv_path ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 ) Simulate Cohort Life Path sim_cohort_path_realised(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000, n_sim = 10000) Parameters: init_age : numeric integer denoting initial age of individuals sex : character character denoting the gender of individuals, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for individuals starting at init_age in 2022 closure_age : numeric maximum age cohort : numeric integer denoting initial cohort size n_sim : numeric integer denoting number of path simulations Returns: a matrix where each row represents the number of individuals still alive from a given cohort at each age An example looks like: \\[\\begin{pmatrix} 1000 & 996 & 991 & 985 & \\ldots & 0 \\\\ 1000 & 998 & 993 & 986 & \\ldots & 0 \\\\ & & \\vdots & & & \\\\ 1000 & 997 & 994 & 986 & \\ldots & 0 \\\\ 1000 & 997 & 992 & 987 & \\ldots & 0 \\end{pmatrix}\\] Note that the first column of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last column will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate life paths for cohort of 1000 females starting at age 60 sim_cohort_path_realised ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider 100 males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_cohort_path_realised ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 , cohort = 100 ) Simulate Expected Cohort Life Path sim_cohort_path_expected(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000) Parameters: init_age : numeric integer denoting initial age of individuals sex : character character denoting the gender of individuals, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for individuals starting at init_age in 2022 closure_age : numeric maximum age cohort : numeric integer denoting initial cohort size Returns: vector of expected number of individuals still alive from a given cohort at each age An example looks like: \\[\\begin{pmatrix} 1000 & 995 & 989 & 981 & \\ldots & 0 \\end{pmatrix}\\] Note that the first entry of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last entry will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate expected life path for cohort of 1000 females starting at age 60 sim_cohort_path_expected ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider 100 males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_cohort_path_expected ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 , cohort = 100 )","title":"Simulating Life Paths"},{"location":"Aggregate%20Mortality/simulation/#simulating-life-paths","text":"One-year death probabilities derived from previous sections can also be used to simulate life paths for a single individual or a cohort of individuals. Each individual or cohort will be alive at a specified initial age, and we sample deaths according to the one-year death probabilities given at each age. When simulating for an individual, we keep track of their dead or alive status at each age. When simulating for a cohort, we keep track of the number of people still alive at each age.","title":"Simulating Life Paths"},{"location":"Aggregate%20Mortality/simulation/#simulate-individual-life-path","text":"sim_indiv_path(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, n_sim = 10000) Parameters: init_age : numeric integer denoting initial age of individuals sex : character character denoting the gender of individuals, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for individuals starting at init_age in 2022 closure_age : numeric maximum age n_sim : numeric integer denoting number of path simulations Returns: a matrix where each row represents an individual's dead (-1) or alive (0) status across the years An example looks like: \\[\\begin{pmatrix} 0 & -1 & -1 & -1 & \\ldots & -1 \\\\ 0 & 0 & 0 & -1 & \\ldots & -1 \\\\ & & \\vdots & & & \\\\ 0 & 0 & 0 & 0 & \\ldots & -1 \\\\ 0 & 0 & -1 & -1 & \\ldots & -1 \\end{pmatrix}\\] Note that the first column of the matrix will always be 0 as everyone is alive at the initial age, and the last column will always be -1, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate life paths for females starting at age 60 sim_indiv_path ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_indiv_path ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 )","title":"Simulate Individual Life Path"},{"location":"Aggregate%20Mortality/simulation/#simulate-cohort-life-path","text":"sim_cohort_path_realised(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000, n_sim = 10000) Parameters: init_age : numeric integer denoting initial age of individuals sex : character character denoting the gender of individuals, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for individuals starting at init_age in 2022 closure_age : numeric maximum age cohort : numeric integer denoting initial cohort size n_sim : numeric integer denoting number of path simulations Returns: a matrix where each row represents the number of individuals still alive from a given cohort at each age An example looks like: \\[\\begin{pmatrix} 1000 & 996 & 991 & 985 & \\ldots & 0 \\\\ 1000 & 998 & 993 & 986 & \\ldots & 0 \\\\ & & \\vdots & & & \\\\ 1000 & 997 & 994 & 986 & \\ldots & 0 \\\\ 1000 & 997 & 992 & 987 & \\ldots & 0 \\end{pmatrix}\\] Note that the first column of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last column will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate life paths for cohort of 1000 females starting at age 60 sim_cohort_path_realised ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider 100 males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_cohort_path_realised ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 , cohort = 100 )","title":"Simulate Cohort Life Path"},{"location":"Aggregate%20Mortality/simulation/#simulate-expected-cohort-life-path","text":"sim_cohort_path_expected(init_age, sex = \"F\", death_probs = NULL, closure_age = 130, cohort = 1000) Parameters: init_age : numeric integer denoting initial age of individuals sex : character character denoting the gender of individuals, \"F\" for female and \"M\" for male death_probs : vector vector of 1-year death probabilities. If not supplied, an M7 age-period-cohort model will be fitted on mortality_AUS_data to produce forecasted death probabilities for individuals starting at init_age in 2022 closure_age : numeric maximum age cohort : numeric integer denoting initial cohort size Returns: vector of expected number of individuals still alive from a given cohort at each age An example looks like: \\[\\begin{pmatrix} 1000 & 995 & 989 & 981 & \\ldots & 0 \\end{pmatrix}\\] Note that the first entry of the matrix will always be the initial cohort size as everyone is alive at the initial age, and the last entry will always be 0, signifying everyone will be dead at age 131 (if we assume 130 is the maximum age one can be). Usage: # Simulate expected life path for cohort of 1000 females starting at age 60 sim_cohort_path_expected ( init_age = 60 , sex = \"F\" ) # Suppose we want to use period 1-yr death probabilities instead AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 AUS_male_qx <- rate2rate ( AUS_male_rates , from = \"central\" , to = \"prob\" ) kannisto_q <- complete_old_age ( AUS_male_qx , ages , old_ages , method = \"kannisto\" , type = \"prob\" , fitted_ages = 80 : 90 ) # Consider 100 males aged 55 in the year 2018 qx_55_2018 <- kannisto_q [ as.character ( 55 : 130 ), \"2018\" ] sim_cohort_path_expected ( init_age = 55 , sex = \"M\" , death_probs = qx_55_2018 , cohort = 100 )","title":"Simulate Expected Cohort Life Path"},{"location":"Aggregate%20Mortality/stats_functions/","text":"Summary Statistics This module includes a set of functions that output summary statistics for the survival functions generated. These include: distribution functions quantile function simulation plots (with confidence ranges) Distribution and quantile functions psurv(surv_fun, surv_time) qsurv(surv_fun, surv_prob) Parameters: surv_fun : vector survival function for a specific cohort/year with survival time rows surv_time : vector vector of survival times surv_prob : vector vector of survival probabilities Returns: vector of probabilites (distribution) or survival times (quantile) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # take vector of survival function (consider year 2017) surv_func_2017 <- surv_func [, \"2017\" ] # calculate probability of surviving 10 and 20 years psurv ( surv_func_2017 , c ( 10 , 20 )) # calculating the 80% and 95% quantile survival time qsurv ( surv_func_2017 , c ( 0.8 , 0.95 )) Survival Function Simulation plot_surv_sim(surv_sim, init_age, target_year, level = 95, years = NULL) Parameters: surv_sim : array survival function with survival time rows, cohort/year columns and simulation number 3rd dimension init_age : numeric integer denoting initial age of surv_sim target_year : numeric year for which the plot is made for level : numeric desired confidence level (default 95%) years : vector optional numeric vector of years for surv_sim Returns: plot of the survival function for the chosen year with confidence intervals Usage: # generate simulated rates with 'StMoMo' # install and load 'StMoMo' if the package is not loaded # fitting lee carter model on ages 55:89 AUS_StMoMo <- StMoMoData ( mortality_AUS_data , series = \"male\" ) LC <- lc ( link = \"logit\" ) # lee carter model AUS_Male_Ini_Data <- central2initial ( AUS_StMoMo ) ages_fit <- 55 : 89 wxy <- genWeightMat ( ages = ages_fit , years = AUS_Male_Ini_Data $ years , clip = 3 ) LC_fit <- fit ( LC , data = AUS_Male_Ini_Data , ages.fit = ages_fit , wxt = wxy ) # simulating rates for next 100 years set.seed ( 1234 ) n_sim <- 10 LC_sim <- simulate ( LC_fit , nsim = n_sim , h = 100 ) # using kannisto method to complete rates young_ages <- LC_sim $ ages # 55:89 old_ages <- 90 : 130 ages <- c ( young_ages , old_ages ) kannisto_sim <- complete_old_age ( rates = LC_sim $ rates , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) # create period survival function for individual aged 55 surv_sim <- rate2survival ( kannisto_sim , ages , from = \"central\" ) plot_surv_sim ( surv_sim , 55 , 2050 ) Expected Curtate Future Lifetime We introduce 2 helper functions combine_hist_sim and exp_cfl to calculate expected curtate future lifetime which is required for plotting. Combine Historical and Simulated Rates combine_hist_sim(rates_hist, rates_sim) Parameters: rates_hist : matrix historical mortality rates with age rows and cohort/year columns rates_sim : array simulated mortality rates with age rows, cohort/year columns and simulation number 3rd dimension Returns: array of combined historical and simulated rates with age rows, cohort/year columns and simulation number 3rd dimension Calculate Expected Curtate Future Lifetime exp_cfl(qx, ages, init_age = NULL, years = NULL) Parameters: qx : matrix/array 1-year death probabilities with age rows, cohort/year columns (and simulation number 3rd dimension ages : vector vector of ages for qx init_age : numeric initial age to calculate expected curtate future lifetime years : vector optional numeric vector of years for qx Returns: matrix of expected curtate future lifetime with simulation number rows and cohort/year columns Plot Expected Curtate Future Lifetime plot_exp_cfl(exp_cfl_rates, years, level = 95) Parameters: exp_cfl_rates : matrix simulated expected curtate future lifetime with simulation number rows and cohort/year columns years : vector numeric vector of years for exp_cfl_rates level : numeric desired confidence level (default 95%) Returns: plot of expected curtate future lifetime with confidence intervals across years/cohorts Usage: # generate simulated rates with 'StMoMo' # install and load 'StMoMo' if the package is not loaded # fitting lee carter model on ages 55:89 AUS_StMoMo <- StMoMoData ( mortality_AUS_data , series = \"male\" ) LC <- lc ( link = \"logit\" ) # lee carter model AUS_Male_Ini_Data <- central2initial ( AUS_StMoMo ) ages_fit <- 55 : 89 wxy <- genWeightMat ( ages = ages_fit , years = AUS_Male_Ini_Data $ years , clip = 3 ) LC_fit <- fit ( LC , data = AUS_Male_Ini_Data , ages.fit = ages_fit , wxt = wxy ) # simulating rates for next 100 years set.seed ( 1234 ) n_sim <- 10 LC_sim <- simulate ( LC_fit , nsim = n_sim , h = 100 ) # using kannisto method to complete rates young_ages <- LC_sim $ ages # 55:89 old_ages <- 90 : 130 ages <- c ( young_ages , old_ages ) rates_hist <- mortality_AUS_data $ rate $ male [ as.character ( young_ages ), ] years_hist <- as.numeric ( colnames ( rates_hist )) years_sim <- LC_sim $ years years <- c ( years_hist , years_sim ) kannisto_sim <- complete_old_age ( rates = LC_sim $ rates , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) kannisto_hist <- complete_old_age ( rates = rates_hist , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) ################# USAGE BEGINS HERE ################ # combining kannisto_55_period <- combine_hist_sim ( rates_hist = kannisto_hist , rates_sim = kannisto_sim ) # working with cohort starting from age 55 kannisto_55 <- period2cohort ( period_rates = kannisto_55_period , ages = ages ) kannisto_55_q <- rate2rate ( kannisto_55 , from = \"central\" , to = \"prob\" ) exp_cfl_kannisto <- exp_cfl ( qx = kannisto_55_q , ages = ages ) # Expected curtate future lifetime can only be computed for # the earlier (complete) cohorts exp_cfl_kannisto_clean <- exp_cfl_kannisto [, as.character ( 1970 : 2043 )] plot_exp_cfl ( exp_cfl_rates = exp_cfl_kannisto_clean , years = 1970 : 2043 )","title":"Summary Statistics"},{"location":"Aggregate%20Mortality/stats_functions/#summary-statistics","text":"This module includes a set of functions that output summary statistics for the survival functions generated. These include: distribution functions quantile function simulation plots (with confidence ranges)","title":"Summary Statistics"},{"location":"Aggregate%20Mortality/stats_functions/#distribution-and-quantile-functions","text":"psurv(surv_fun, surv_time) qsurv(surv_fun, surv_prob) Parameters: surv_fun : vector survival function for a specific cohort/year with survival time rows surv_time : vector vector of survival times surv_prob : vector vector of survival probabilities Returns: vector of probabilites (distribution) or survival times (quantile) Usage: # create survival function for an individual aged 55 AUS_male_rates <- mortality_AUS_data $ rate $ male ages <- mortality_AUS_data $ age # 0:110 old_ages <- 91 : 130 fitted_ages <- 76 : 90 completed_rates <- complete_old_age ( AUS_male_rates , ages , old_ages , method = \"kannisto\" , type = \"central\" , fitted_ages = fitted_ages ) all_ages <- 0 : 130 surv_func <- rate2survival ( completed_rates , ages = all_ages , from = 'central' , init_age = 55 ) # take vector of survival function (consider year 2017) surv_func_2017 <- surv_func [, \"2017\" ] # calculate probability of surviving 10 and 20 years psurv ( surv_func_2017 , c ( 10 , 20 )) # calculating the 80% and 95% quantile survival time qsurv ( surv_func_2017 , c ( 0.8 , 0.95 ))","title":"Distribution and quantile functions"},{"location":"Aggregate%20Mortality/stats_functions/#survival-function-simulation","text":"plot_surv_sim(surv_sim, init_age, target_year, level = 95, years = NULL) Parameters: surv_sim : array survival function with survival time rows, cohort/year columns and simulation number 3rd dimension init_age : numeric integer denoting initial age of surv_sim target_year : numeric year for which the plot is made for level : numeric desired confidence level (default 95%) years : vector optional numeric vector of years for surv_sim Returns: plot of the survival function for the chosen year with confidence intervals Usage: # generate simulated rates with 'StMoMo' # install and load 'StMoMo' if the package is not loaded # fitting lee carter model on ages 55:89 AUS_StMoMo <- StMoMoData ( mortality_AUS_data , series = \"male\" ) LC <- lc ( link = \"logit\" ) # lee carter model AUS_Male_Ini_Data <- central2initial ( AUS_StMoMo ) ages_fit <- 55 : 89 wxy <- genWeightMat ( ages = ages_fit , years = AUS_Male_Ini_Data $ years , clip = 3 ) LC_fit <- fit ( LC , data = AUS_Male_Ini_Data , ages.fit = ages_fit , wxt = wxy ) # simulating rates for next 100 years set.seed ( 1234 ) n_sim <- 10 LC_sim <- simulate ( LC_fit , nsim = n_sim , h = 100 ) # using kannisto method to complete rates young_ages <- LC_sim $ ages # 55:89 old_ages <- 90 : 130 ages <- c ( young_ages , old_ages ) kannisto_sim <- complete_old_age ( rates = LC_sim $ rates , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) # create period survival function for individual aged 55 surv_sim <- rate2survival ( kannisto_sim , ages , from = \"central\" ) plot_surv_sim ( surv_sim , 55 , 2050 )","title":"Survival Function Simulation"},{"location":"Aggregate%20Mortality/stats_functions/#expected-curtate-future-lifetime","text":"We introduce 2 helper functions combine_hist_sim and exp_cfl to calculate expected curtate future lifetime which is required for plotting.","title":"Expected Curtate Future Lifetime"},{"location":"Aggregate%20Mortality/stats_functions/#combine-historical-and-simulated-rates","text":"combine_hist_sim(rates_hist, rates_sim) Parameters: rates_hist : matrix historical mortality rates with age rows and cohort/year columns rates_sim : array simulated mortality rates with age rows, cohort/year columns and simulation number 3rd dimension Returns: array of combined historical and simulated rates with age rows, cohort/year columns and simulation number 3rd dimension","title":"Combine Historical and Simulated Rates"},{"location":"Aggregate%20Mortality/stats_functions/#calculate-expected-curtate-future-lifetime","text":"exp_cfl(qx, ages, init_age = NULL, years = NULL) Parameters: qx : matrix/array 1-year death probabilities with age rows, cohort/year columns (and simulation number 3rd dimension ages : vector vector of ages for qx init_age : numeric initial age to calculate expected curtate future lifetime years : vector optional numeric vector of years for qx Returns: matrix of expected curtate future lifetime with simulation number rows and cohort/year columns","title":"Calculate Expected Curtate Future Lifetime"},{"location":"Aggregate%20Mortality/stats_functions/#plot-expected-curtate-future-lifetime","text":"plot_exp_cfl(exp_cfl_rates, years, level = 95) Parameters: exp_cfl_rates : matrix simulated expected curtate future lifetime with simulation number rows and cohort/year columns years : vector numeric vector of years for exp_cfl_rates level : numeric desired confidence level (default 95%) Returns: plot of expected curtate future lifetime with confidence intervals across years/cohorts Usage: # generate simulated rates with 'StMoMo' # install and load 'StMoMo' if the package is not loaded # fitting lee carter model on ages 55:89 AUS_StMoMo <- StMoMoData ( mortality_AUS_data , series = \"male\" ) LC <- lc ( link = \"logit\" ) # lee carter model AUS_Male_Ini_Data <- central2initial ( AUS_StMoMo ) ages_fit <- 55 : 89 wxy <- genWeightMat ( ages = ages_fit , years = AUS_Male_Ini_Data $ years , clip = 3 ) LC_fit <- fit ( LC , data = AUS_Male_Ini_Data , ages.fit = ages_fit , wxt = wxy ) # simulating rates for next 100 years set.seed ( 1234 ) n_sim <- 10 LC_sim <- simulate ( LC_fit , nsim = n_sim , h = 100 ) # using kannisto method to complete rates young_ages <- LC_sim $ ages # 55:89 old_ages <- 90 : 130 ages <- c ( young_ages , old_ages ) rates_hist <- mortality_AUS_data $ rate $ male [ as.character ( young_ages ), ] years_hist <- as.numeric ( colnames ( rates_hist )) years_sim <- LC_sim $ years years <- c ( years_hist , years_sim ) kannisto_sim <- complete_old_age ( rates = LC_sim $ rates , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) kannisto_hist <- complete_old_age ( rates = rates_hist , ages = young_ages , old_ages = old_ages , fitted_ages = 80 : 89 , method = \"kannisto\" , type = \"central\" ) ################# USAGE BEGINS HERE ################ # combining kannisto_55_period <- combine_hist_sim ( rates_hist = kannisto_hist , rates_sim = kannisto_sim ) # working with cohort starting from age 55 kannisto_55 <- period2cohort ( period_rates = kannisto_55_period , ages = ages ) kannisto_55_q <- rate2rate ( kannisto_55 , from = \"central\" , to = \"prob\" ) exp_cfl_kannisto <- exp_cfl ( qx = kannisto_55_q , ages = ages ) # Expected curtate future lifetime can only be computed for # the earlier (complete) cohorts exp_cfl_kannisto_clean <- exp_cfl_kannisto [, as.character ( 1970 : 2043 )] plot_exp_cfl ( exp_cfl_rates = exp_cfl_kannisto_clean , years = 1970 : 2043 )","title":"Plot Expected Curtate Future Lifetime"},{"location":"Economic%20Scenario%20Generator/cts_esg/","text":"Continuous-Time Generator The continuous-time economic scenario generator simulates the trajectories of: (1) Australia zero-coupon bond rates maturing every quarter from 3 months up to 10 years, i.e., 0.25 years, 0.5 years, 0.75 years, ..., 10 years, (2) NSW home value index, (3) S&P/ASX200 price. The zero-coupon bond term structure is fitted using the arbitrage-free Nelson-Siegel model, while NSW home value index and S&P/ASX200 price are assumed to be Geometric Brownian Motions that are correlated with the zero-coupon bond rates. The independent-factor model assumes that the level, slope, and curvature of the risk-free rate are mutually independent, while the correlated-factor model assumes dependence among them. Simulations generated by the correlated-factor models are more variable since more parameters are involved. Denote \\(X^1\\) the level, \\(X^2\\) the slope, \\(X^3\\) the curvature of the risk-free rate, \\(X^4\\) the logged NSW home value index, \\(X^5\\) the S&P/ASX200 price, \\(W^1, \\cdots, W^5\\) the standard Brownian Motions. The independent-factor model satisfies the following stochastic differential equation: and the correlated-factor model satisfies The results are still depicted with the same simulation frequency options as the discrete case, but the calculations are based in continuous time. get_afns_simulation(num_years = 5, num_paths = 10, frequency = 'month', type = 'independent', model = 'interest_rate') Paramters: num_years : numeric integer denoting number of years to forecast from 2021-06-01 num_paths : numeric integer denoting the number of simulation paths frequency : character 'year', 'quarter' or 'month' denoting the simulation frequency type : character 'independent' or 'correlated' denoting whether the latent factors are independent of each other model : character 'interest_rate' or 'interest_house_stock' denoting the output variables Returns: A list of 40 dataframes containing simulated interest rates with maturities from 1 quarter up to 10 years, or 42 dataframes containing interest rates, NSW house value index, S&P/ASX200 closing prices if model is set to be interest_house_stock. Usage: # simulate 10 years of data sim <- get_afns_simulation ( num_years = 10 , num_paths = 10000 , frequency = 'year' , type = 'independent' , model = 'interest_house_stock' ) # suppose we wish to look at the 3-month zero-coupon bond rates sim $ maturity_1qtrs # suppose we wish to look at the 5-year zero-coupon bond rates sim $ maturity_20qtrs # NSW house value index sim $ house_index # S&P/ASX200 closing price sim $ stock_price References: Christensen, J. H., Diebold, F. X. & Rudebusch, G. D. (2011), \u2018The affine arbitrage-free class of nelson\u2013siegel term structure models\u2019, Journal of Econometrics 164(1), 4\u201320. Christensen, J. H., Lopez, J. A. & Rudebusch, G. D. (2015), \u2018Analytical formulas for the second moment in affine models with stochastic volatility\u2019.","title":"Continuous-Time Generator"},{"location":"Economic%20Scenario%20Generator/cts_esg/#continuous-time-generator","text":"The continuous-time economic scenario generator simulates the trajectories of: (1) Australia zero-coupon bond rates maturing every quarter from 3 months up to 10 years, i.e., 0.25 years, 0.5 years, 0.75 years, ..., 10 years, (2) NSW home value index, (3) S&P/ASX200 price. The zero-coupon bond term structure is fitted using the arbitrage-free Nelson-Siegel model, while NSW home value index and S&P/ASX200 price are assumed to be Geometric Brownian Motions that are correlated with the zero-coupon bond rates. The independent-factor model assumes that the level, slope, and curvature of the risk-free rate are mutually independent, while the correlated-factor model assumes dependence among them. Simulations generated by the correlated-factor models are more variable since more parameters are involved. Denote \\(X^1\\) the level, \\(X^2\\) the slope, \\(X^3\\) the curvature of the risk-free rate, \\(X^4\\) the logged NSW home value index, \\(X^5\\) the S&P/ASX200 price, \\(W^1, \\cdots, W^5\\) the standard Brownian Motions. The independent-factor model satisfies the following stochastic differential equation: and the correlated-factor model satisfies The results are still depicted with the same simulation frequency options as the discrete case, but the calculations are based in continuous time. get_afns_simulation(num_years = 5, num_paths = 10, frequency = 'month', type = 'independent', model = 'interest_rate') Paramters: num_years : numeric integer denoting number of years to forecast from 2021-06-01 num_paths : numeric integer denoting the number of simulation paths frequency : character 'year', 'quarter' or 'month' denoting the simulation frequency type : character 'independent' or 'correlated' denoting whether the latent factors are independent of each other model : character 'interest_rate' or 'interest_house_stock' denoting the output variables Returns: A list of 40 dataframes containing simulated interest rates with maturities from 1 quarter up to 10 years, or 42 dataframes containing interest rates, NSW house value index, S&P/ASX200 closing prices if model is set to be interest_house_stock. Usage: # simulate 10 years of data sim <- get_afns_simulation ( num_years = 10 , num_paths = 10000 , frequency = 'year' , type = 'independent' , model = 'interest_house_stock' ) # suppose we wish to look at the 3-month zero-coupon bond rates sim $ maturity_1qtrs # suppose we wish to look at the 5-year zero-coupon bond rates sim $ maturity_20qtrs # NSW house value index sim $ house_index # S&P/ASX200 closing price sim $ stock_price References: Christensen, J. H., Diebold, F. X. & Rudebusch, G. D. (2011), \u2018The affine arbitrage-free class of nelson\u2013siegel term structure models\u2019, Journal of Econometrics 164(1), 4\u201320. Christensen, J. H., Lopez, J. A. & Rudebusch, G. D. (2015), \u2018Analytical formulas for the second moment in affine models with stochastic volatility\u2019.","title":"Continuous-Time Generator"},{"location":"Economic%20Scenario%20Generator/discrete_esg/","text":"Discrete-Time Generator The discrete-time economic scenario generator simulates the trajectories of 11 Australian economic and financial variables: (1) 3-month zero-coupon bond yields, (2) 10-year zero-coupon bond spread, (3) NSW home value index, (4) NSW home rental yields, (5) Australia GDP, (6) Australia CPI, (7) S&P/ASX200 closing price, (8) Australian dollar trade-weighted index, (9) Australia mortgage rate, (10) NSW unemployment rate, (11) Stochastic discount factors (pricing kernels). The factors (1)-(8) were fitted using a Vector Autoregressive model (VAR), factors (9)-(10) were respectively expressed as a fixed margin over factors (1)-(2) due to strong correlations, while factor (11) is derived from the VAR with arbitrage-free assumptions. Vector Autoregression (VAR) is a regression of a time series where the ouput depends linearly on the past values of itself, and the past values of other variables, up to some specfied order: where \\(\\mathbf{z}_{t}\\) is the vector of economic variables, \\(\\boldsymbol{\\mu}\\) is the vector of intercepts, \\(\\Phi_{i}\\) , for \\(i=1,\\cdots, p\\) are coefficient matrices of size \\(n \\times n\\) with \\(n\\) being the number of economic variables and \\(p\\) the lags. \\(\\boldsymbol{\\epsilon}\\) is a vector of white noises. The stochastic discount factor is defined as: where \\(\\mathbf{e}_1^\\top \\mathbf{z}_t\\) and \\(\\mathbf{\\epsilon}_t\\) respectively denote the 3-month zero-coupon bond rates and the white noises from the fitted VAR model, and \\(\\mathbf{\\lambda}_t\\) is the market price of risk process. get_var_simulations(num_years = 5, num_paths = 10, frequency = 'quarter', per_change = FALSE, return_sdf = FALSE) Parameters: num_years : numeric integer denoting number of years to forecast from 2021-01-01 num_paths : numeric integer denoting number of simulations to make for each variable frequency : character 'year', 'quarter' or 'month' denoting the simulation frequency perc_change : logical set TRUE for outputs to be expressed as percent change return_sdf : logical set TRUE to return the stochastic discount factors Returns: A list of 10 dataframes containing simulated trajectories of the 10 variables, or a list of 11 dataframes including the simulated stochastic discount factors if return_sdf is set TRUE. Usage: # simulate 10 years of data sim <- get_var_simulations ( num_years = 10 , num_paths = 10000 , frequency = 'year' ) # suppose we wish to look at the 3 months zero coupon bonds sim $ zcp3m_yield # if we wanted a specific trajectory, say 103 sim $ zcp3m_yield $ trajectory_103 References: Daniel H Alai, Hua Chen, Daniel Cho, Katja Hanewald, and Michael Sherris. Developing equity release markets: Risk analysis for reverse mortgages and home reversions. North American Actuarial Journal , 18(1):217\u2013241, 2014. Andrew Ang and Monika Piazzesi. A no-arbitrage vector autoregression of term structure dynamics with macroeconomic and latent variables. Journal of Monetary economics , 50(4):745\u2013787, 2003. Andrew Ang, Monika Piazzesi, and Min Wei. What does the yield curve tell us about gdp growth? Journal of econometrics , 131(1-2):359\u2013403, 2006.","title":"Discrete-Time Generator"},{"location":"Economic%20Scenario%20Generator/discrete_esg/#discrete-time-generator","text":"The discrete-time economic scenario generator simulates the trajectories of 11 Australian economic and financial variables: (1) 3-month zero-coupon bond yields, (2) 10-year zero-coupon bond spread, (3) NSW home value index, (4) NSW home rental yields, (5) Australia GDP, (6) Australia CPI, (7) S&P/ASX200 closing price, (8) Australian dollar trade-weighted index, (9) Australia mortgage rate, (10) NSW unemployment rate, (11) Stochastic discount factors (pricing kernels). The factors (1)-(8) were fitted using a Vector Autoregressive model (VAR), factors (9)-(10) were respectively expressed as a fixed margin over factors (1)-(2) due to strong correlations, while factor (11) is derived from the VAR with arbitrage-free assumptions. Vector Autoregression (VAR) is a regression of a time series where the ouput depends linearly on the past values of itself, and the past values of other variables, up to some specfied order: where \\(\\mathbf{z}_{t}\\) is the vector of economic variables, \\(\\boldsymbol{\\mu}\\) is the vector of intercepts, \\(\\Phi_{i}\\) , for \\(i=1,\\cdots, p\\) are coefficient matrices of size \\(n \\times n\\) with \\(n\\) being the number of economic variables and \\(p\\) the lags. \\(\\boldsymbol{\\epsilon}\\) is a vector of white noises. The stochastic discount factor is defined as: where \\(\\mathbf{e}_1^\\top \\mathbf{z}_t\\) and \\(\\mathbf{\\epsilon}_t\\) respectively denote the 3-month zero-coupon bond rates and the white noises from the fitted VAR model, and \\(\\mathbf{\\lambda}_t\\) is the market price of risk process. get_var_simulations(num_years = 5, num_paths = 10, frequency = 'quarter', per_change = FALSE, return_sdf = FALSE) Parameters: num_years : numeric integer denoting number of years to forecast from 2021-01-01 num_paths : numeric integer denoting number of simulations to make for each variable frequency : character 'year', 'quarter' or 'month' denoting the simulation frequency perc_change : logical set TRUE for outputs to be expressed as percent change return_sdf : logical set TRUE to return the stochastic discount factors Returns: A list of 10 dataframes containing simulated trajectories of the 10 variables, or a list of 11 dataframes including the simulated stochastic discount factors if return_sdf is set TRUE. Usage: # simulate 10 years of data sim <- get_var_simulations ( num_years = 10 , num_paths = 10000 , frequency = 'year' ) # suppose we wish to look at the 3 months zero coupon bonds sim $ zcp3m_yield # if we wanted a specific trajectory, say 103 sim $ zcp3m_yield $ trajectory_103 References: Daniel H Alai, Hua Chen, Daniel Cho, Katja Hanewald, and Michael Sherris. Developing equity release markets: Risk analysis for reverse mortgages and home reversions. North American Actuarial Journal , 18(1):217\u2013241, 2014. Andrew Ang and Monika Piazzesi. A no-arbitrage vector autoregression of term structure dynamics with macroeconomic and latent variables. Journal of Monetary economics , 50(4):745\u2013787, 2003. Andrew Ang, Monika Piazzesi, and Min Wei. What does the yield curve tell us about gdp growth? Journal of econometrics , 131(1-2):359\u2013403, 2006.","title":"Discrete-Time Generator"},{"location":"Economic%20Scenario%20Generator/overview/","text":"Overview To price a financial product/instrument that will have cashflows in the future, the present time valuation requires a set of assumptions on different economic factors. The purpose of this module is to simulate a set of 11 economic variables that will characterise the economic envrionment for a specified amount of time into the future. The 10 economic factors that will be simulated are: 3-month zero-coupon yield, 10-year zero-coupon spread, NSW hedonic house value index, NSW house rental yields, Australia GDP, Australia CPI, S&P/ASX200 closing price, Australian dollar trade-weighted index, Australia mortgage rate, NSW unemployment rate, Stochastic discount factors (pricing kernels). These 11 factors can provide a comprehensive picture of the economic environment in the future, which is useful for projecting investments/financial products into the future, as well as discounting future cash flows to more accurately gauge present value. This allows for broad appliations in insurance pricing, loan/debt pricing, and project valuations. The module has a discrete-time economic scenario generator (ESG), and a continuous-time ESG. The discrete-time ESG is fit on discrete time intervals, whereas continuous-time ESG's can in theory be fit for any time point. However, the module uses the same simulation frequencies for both ESG types.","title":"Overview"},{"location":"Economic%20Scenario%20Generator/overview/#overview","text":"To price a financial product/instrument that will have cashflows in the future, the present time valuation requires a set of assumptions on different economic factors. The purpose of this module is to simulate a set of 11 economic variables that will characterise the economic envrionment for a specified amount of time into the future. The 10 economic factors that will be simulated are: 3-month zero-coupon yield, 10-year zero-coupon spread, NSW hedonic house value index, NSW house rental yields, Australia GDP, Australia CPI, S&P/ASX200 closing price, Australian dollar trade-weighted index, Australia mortgage rate, NSW unemployment rate, Stochastic discount factors (pricing kernels). These 11 factors can provide a comprehensive picture of the economic environment in the future, which is useful for projecting investments/financial products into the future, as well as discounting future cash flows to more accurately gauge present value. This allows for broad appliations in insurance pricing, loan/debt pricing, and project valuations. The module has a discrete-time economic scenario generator (ESG), and a continuous-time ESG. The discrete-time ESG is fit on discrete time intervals, whereas continuous-time ESG's can in theory be fit for any time point. However, the module uses the same simulation frequencies for both ESG types.","title":"Overview"},{"location":"Economic%20Scenario%20Generator/top3/","text":"Topic 3 For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Topic 3"},{"location":"Economic%20Scenario%20Generator/top3/#topic-3","text":"For full documentation visit mkdocs.org .","title":"Topic 3"},{"location":"Economic%20Scenario%20Generator/top3/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Economic%20Scenario%20Generator/top3/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Health/overview/","text":"This module will produce transition probabilities for health state and functional disability models for a specified initial age (from 50 to 65 up to age 110) and health state based on the calibrated parametrization of models. Models to include static models, improvement trends in transition rates and stochastic transition rates (latent factor). Models will include functional disability based on: Various ADL\u2019s (2+, 3+, cognitive decline) with recovery Joint health status Disability states based on core activities for Australian applications Output will include: Probability transition matrices for different starting ages derived from transition rates, with trends Expected transition rates and simulated future transition rates for stochastic simulations Models will be included to forecast the Australian prevalence of disabled populations based on functional disability models.","title":"Overview"},{"location":"Health/Health%20State%203/3state_examples/","text":"Workflow Example The following is an example of the general workflow of the module. It demonstrates the order of function executions, and the different endpoint outputs. We use the following individual characteristics: male age 87 initial year 2022 trend model healthy use parameters estimated from the US study: US_HRS # first we create a list of transition probability matrices trans_probs <- get_trans_probs ( 'T' , US_HRS , 87 , female = 0 , 2022 ) # using the transition probabilities, we can generate life tables life_table <- create_life_table ( trans_probs , 87 , init_state = 0 ) head ( life_table ) # can also create a plot of mortality and disability curves prob_plots ( init_state = 0 , 87 , trans_probs ) # from transition probabilities, we can simulate lifetime paths sim_paths <- simulate_path ( 87 , init_state = 0 , trans_probs , cohort = 10000 ) # statistics (mean and standard deviation): # average future lifetime future_life <- afl ( 87 , init_state = 0 , trans_probs ) # healthy future lifetime healthy_life <- hfl ( 87 , init_state = 0 , trans_probs ) # average future lifetime spent in disabled state disabled_life <- afld ( 87 , init_state = 0 , trans_probs ) # time until onset of disability first_disabled <- time_to_disabled ( 87 , trans_probs ) # all survival statistics (essentially all of the above outputted in one dataframe) survival_stats ( 87 , init_state = 0 , trans_probs ) Note If we used the frailty model, then the transition probabilities, lifetable, and plots will also be stochastic, in addition to another layer of randomness in the other simulated variables. Also use corresponding frailty version of the statistics functions for the extra layer of randomness. See 3 state stats .","title":"Workflow Example"},{"location":"Health/Health%20State%203/3state_examples/#workflow-example","text":"The following is an example of the general workflow of the module. It demonstrates the order of function executions, and the different endpoint outputs. We use the following individual characteristics: male age 87 initial year 2022 trend model healthy use parameters estimated from the US study: US_HRS # first we create a list of transition probability matrices trans_probs <- get_trans_probs ( 'T' , US_HRS , 87 , female = 0 , 2022 ) # using the transition probabilities, we can generate life tables life_table <- create_life_table ( trans_probs , 87 , init_state = 0 ) head ( life_table ) # can also create a plot of mortality and disability curves prob_plots ( init_state = 0 , 87 , trans_probs ) # from transition probabilities, we can simulate lifetime paths sim_paths <- simulate_path ( 87 , init_state = 0 , trans_probs , cohort = 10000 ) # statistics (mean and standard deviation): # average future lifetime future_life <- afl ( 87 , init_state = 0 , trans_probs ) # healthy future lifetime healthy_life <- hfl ( 87 , init_state = 0 , trans_probs ) # average future lifetime spent in disabled state disabled_life <- afld ( 87 , init_state = 0 , trans_probs ) # time until onset of disability first_disabled <- time_to_disabled ( 87 , trans_probs ) # all survival statistics (essentially all of the above outputted in one dataframe) survival_stats ( 87 , init_state = 0 , trans_probs ) Note If we used the frailty model, then the transition probabilities, lifetable, and plots will also be stochastic, in addition to another layer of randomness in the other simulated variables. Also use corresponding frailty version of the statistics functions for the extra layer of randomness. See 3 state stats .","title":"Workflow Example"},{"location":"Health/Health%20State%203/cox_model/","text":"Cox Hazard Model General Principle The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for an individual \\(k\\) and transition type \\(s\\) is: \\[\\lambda_{k, s}(t) = \\text{exp}(\\boldsymbol{\\beta}_{s}'\\mathbf{X}_k) \\cdot H_{k, s}(t)\\] In the above forumlation, \\(\\boldsymbol{\\beta}\\) contains coefficients of transition type \\(s\\) to be estimated, and \\(\\mathbf{X}\\) contains the covariates of individual \\(k\\) . Furthermore, we assume the Markovaian property where \\(H_{k, s}(t) = 1\\) . Three Models Static Model \\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k \\] where \\(x_k(t)\\) represents the age for the \\(k\\) th individual at time t and \\(F_k = 1\\) if the \\(k\\) th individual is female. The coefficients are parameters to be estimated. Trend Model \\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t \\] where \\(t\\) is the time trend. Note that \\(t=1\\) corresponds to the year 1998-1999. Frailty Model \\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t + \\alpha_s \\psi(t) \\] where \\(\\psi(t)\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi(t) = \\psi(t-1) + \\epsilon\\) with \\(\\epsilon \\sim \\text{N}(0, 1)\\) . Parameters The module uses cox hazard model parameters estimated from external research studies. The parameters of the two following studies are included in the package: US Health and Retirement Study (parameter name: US_HRS) China Chinese Longitudinal Healthy Longevity Survey (parameter name: china_CLHLS)","title":"Cox Hazard Model"},{"location":"Health/Health%20State%203/cox_model/#cox-hazard-model","text":"","title":"Cox Hazard Model"},{"location":"Health/Health%20State%203/cox_model/#general-principle","text":"The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for an individual \\(k\\) and transition type \\(s\\) is: \\[\\lambda_{k, s}(t) = \\text{exp}(\\boldsymbol{\\beta}_{s}'\\mathbf{X}_k) \\cdot H_{k, s}(t)\\] In the above forumlation, \\(\\boldsymbol{\\beta}\\) contains coefficients of transition type \\(s\\) to be estimated, and \\(\\mathbf{X}\\) contains the covariates of individual \\(k\\) . Furthermore, we assume the Markovaian property where \\(H_{k, s}(t) = 1\\) .","title":"General Principle"},{"location":"Health/Health%20State%203/cox_model/#three-models","text":"","title":"Three Models"},{"location":"Health/Health%20State%203/cox_model/#static-model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k \\] where \\(x_k(t)\\) represents the age for the \\(k\\) th individual at time t and \\(F_k = 1\\) if the \\(k\\) th individual is female. The coefficients are parameters to be estimated.","title":"Static Model"},{"location":"Health/Health%20State%203/cox_model/#trend-model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t \\] where \\(t\\) is the time trend. Note that \\(t=1\\) corresponds to the year 1998-1999.","title":"Trend Model"},{"location":"Health/Health%20State%203/cox_model/#frailty-model","text":"\\[ \\text{ln}\\lambda_{k, s}(t) = \\beta_s + \\gamma^{\\text{age}}_s x_k(t) + \\gamma^{\\text{female}}_s F_k + \\gamma^{\\text{time}}_s t + \\alpha_s \\psi(t) \\] where \\(\\psi(t)\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi(t) = \\psi(t-1) + \\epsilon\\) with \\(\\epsilon \\sim \\text{N}(0, 1)\\) .","title":"Frailty Model"},{"location":"Health/Health%20State%203/cox_model/#parameters","text":"The module uses cox hazard model parameters estimated from external research studies. The parameters of the two following studies are included in the package: US Health and Retirement Study (parameter name: US_HRS) China Chinese Longitudinal Healthy Longevity Survey (parameter name: china_CLHLS)","title":"Parameters"},{"location":"Health/Health%20State%203/lifetable/","text":"Life Table Generation We can create a cohort multi-state lifetable for a specified individual using the corresponding transition probability matrices. This can be used for the following applications: calculating probability of survival to different states calculating remaining life expectancy Given a set of transition probability matrices, the life table that is generated is always deterministic; it is generated off of expected values and not simulation. The lifetable shows the number of lives in different states at each age, as well as the amount of people that transition between states. The lifetable ends at 110, and everyone still alive is assumed to die during age 110-111. One can also specify the initial state that the cohort is in for the life table: healthy (default) or disabled. Generating a Life Table create_life_table(trans_probs, age, init_state) Paramters: trans_probs : list list of transition probability matrices; typically generated by get_trans_probs age : numeric numeric denoting initial age of individual init_state : numeric initial state of cohort: 0 for healthy, 1 for disabled Returns: lifetable as a dataframe Usage: # list of transition probability matrices under the trend model, # using US_HRS parameters of 65 year old male in 2021 trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , 0 , 2021 ) # generate life table from the transition probability with starting # cohort of 10,000 (default) life_table <- create_life_table ( trans_probs , 65 , 0 )","title":"Life Table Generation"},{"location":"Health/Health%20State%203/lifetable/#life-table-generation","text":"We can create a cohort multi-state lifetable for a specified individual using the corresponding transition probability matrices. This can be used for the following applications: calculating probability of survival to different states calculating remaining life expectancy Given a set of transition probability matrices, the life table that is generated is always deterministic; it is generated off of expected values and not simulation. The lifetable shows the number of lives in different states at each age, as well as the amount of people that transition between states. The lifetable ends at 110, and everyone still alive is assumed to die during age 110-111. One can also specify the initial state that the cohort is in for the life table: healthy (default) or disabled.","title":"Life Table Generation"},{"location":"Health/Health%20State%203/lifetable/#generating-a-life-table","text":"create_life_table(trans_probs, age, init_state) Paramters: trans_probs : list list of transition probability matrices; typically generated by get_trans_probs age : numeric numeric denoting initial age of individual init_state : numeric initial state of cohort: 0 for healthy, 1 for disabled Returns: lifetable as a dataframe Usage: # list of transition probability matrices under the trend model, # using US_HRS parameters of 65 year old male in 2021 trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , 0 , 2021 ) # generate life table from the transition probability with starting # cohort of 10,000 (default) life_table <- create_life_table ( trans_probs , 65 , 0 )","title":"Generating a Life Table"},{"location":"Health/Health%20State%203/overview/","text":"Overview: 3-State This module conducts mortality analysis using the 3 state model with the following transitions: The three states are: H: Healthy F: Disabled D: Dead Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. Functionalities of the module includes: Calculating transition probability matrices from parameters of Cox Regression model Creating life tables for a certain individual characteristic Simulating lifetime paths Returning key survival statistics for a certain individual These functions can be helpful in conducting mortality studies, as well as applications in insurance pricing. The general overview and usage of the module can be seen in the following flowchart:","title":"Overview: 3-State"},{"location":"Health/Health%20State%203/overview/#overview-3-state","text":"This module conducts mortality analysis using the 3 state model with the following transitions: The three states are: H: Healthy F: Disabled D: Dead Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. Functionalities of the module includes: Calculating transition probability matrices from parameters of Cox Regression model Creating life tables for a certain individual characteristic Simulating lifetime paths Returning key survival statistics for a certain individual These functions can be helpful in conducting mortality studies, as well as applications in insurance pricing. The general overview and usage of the module can be seen in the following flowchart:","title":"Overview: 3-State"},{"location":"Health/Health%20State%203/simulation/","text":"Simulating Life Paths Expected values are easily derived from the transition probabilities, but some form of simulation is required to analyse variance of risks. Simulation can be performed by using the transition probability matrices. Everyone starts in a certain health state (0 for healthy and 1 for disabled), and we sample movements according to the probabilities given at each age. Death state, -1, is absorbing. Simulating lives simulate_path(init_age, init_state, trans_probs, cohort = 10000) Parameters: init_age : numeric numeric denoting initial age init_state : numeric initial state of cohort: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices; typically generated by get_trans_probs cohort : numeric integer denoting number of individual lives to simulate Returns: a matrix where each row represents a single individual's state transitions across the years. An example looks like: \\[\\begin{pmatrix} 0 & 0 & 1 & 0 & \\ldots & -1 \\\\ 0 & 0 & 0 & 0 & \\ldots & -1 \\\\ & & \\vdots & & & \\\\ 0 & 1 & 1 & 1 & \\ldots & -1 \\\\ 0 & 0 & -1 & -1 & \\ldots & -1 \\end{pmatrix}\\] Note that the first column of the matrix will always be initial state provided in the parameters, and the last column will always be -1, signifying everyone will be dead at age 111 (110 is the maximum age of the model). Usage: # list of transition probability matrices under the trend model, # using US_HRS parameters of 65 year old male in 2021 trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , 0 , 2021 ) # create simulated paths for 10,000 (default cohort size) individuals # given initial age 65 and initial state in healthy SP <- simulate_paths ( 65 , 0 , trans_probs )","title":"Simulating Life Paths"},{"location":"Health/Health%20State%203/simulation/#simulating-life-paths","text":"Expected values are easily derived from the transition probabilities, but some form of simulation is required to analyse variance of risks. Simulation can be performed by using the transition probability matrices. Everyone starts in a certain health state (0 for healthy and 1 for disabled), and we sample movements according to the probabilities given at each age. Death state, -1, is absorbing.","title":"Simulating Life Paths"},{"location":"Health/Health%20State%203/simulation/#simulating-lives","text":"simulate_path(init_age, init_state, trans_probs, cohort = 10000) Parameters: init_age : numeric numeric denoting initial age init_state : numeric initial state of cohort: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices; typically generated by get_trans_probs cohort : numeric integer denoting number of individual lives to simulate Returns: a matrix where each row represents a single individual's state transitions across the years. An example looks like: \\[\\begin{pmatrix} 0 & 0 & 1 & 0 & \\ldots & -1 \\\\ 0 & 0 & 0 & 0 & \\ldots & -1 \\\\ & & \\vdots & & & \\\\ 0 & 1 & 1 & 1 & \\ldots & -1 \\\\ 0 & 0 & -1 & -1 & \\ldots & -1 \\end{pmatrix}\\] Note that the first column of the matrix will always be initial state provided in the parameters, and the last column will always be -1, signifying everyone will be dead at age 111 (110 is the maximum age of the model). Usage: # list of transition probability matrices under the trend model, # using US_HRS parameters of 65 year old male in 2021 trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , 0 , 2021 ) # create simulated paths for 10,000 (default cohort size) individuals # given initial age 65 and initial state in healthy SP <- simulate_paths ( 65 , 0 , trans_probs )","title":"Simulating lives"},{"location":"Health/Health%20State%203/stats/","text":"Statistics A lot of mortality statistics can be generated to analyse survival of a certain individual. The following functions return the expected value and variance associated with the lifetime statistic. The functions can use either of the different inputs below to produce the required statistic: list of transition probability matrices from get_trans_probs simulated path matrix from simulate_path If the first option is used, the functions use simulation to find expected value and variance. Hence, there is a stochastic component to these results. If both inputs are provided, then the simulated path wil be used, and no simulation will occur within the function. Each function comes with a frailty version, which has the same name with an 'F' attached to it (eg. afl -> aflF ). The frailty version simulates 'n' unique latent paths, which adds another level of randomness in the statistic. It also requires the same parameters needed to produce a new set of transition probability matrices (see below examples). By default, frailty functions simulate 1000 unique latent factors. For all code examples below, we will use an male individual aged 65 in year 2022. Average Future Lifetime: afl ( aflF ) The function calculates the average future lifetime for a given individual, and its variance. afl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of average future lifetime Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate average future lifetime afl ( 65 , init_state = 0 , trans_probs ) aflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of indiviudal: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of average future lifetime Usage: aflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS ) Healthy Future Lifetime hfl ( hflF ) This function calculates the average future lifetime spent in the healthy state, and its variance. hfl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of healthy future lifetime Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate healthy future lifetime hfl ( 65 , init_state = 0 , trans_probs ) hflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of indiviudal: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of healthy future lifetime Usage: hflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS ) Average Future Lifetime in Disabled State: afld ( afldF ) This function calculates the average future lifetime spent in the disabled state, and its variance. Not that under the same simulated lifetime, average future lifetime is equal to the sum of healthy lifetime and disabled lifetime. afld(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of average lifetime spent in disabled state Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate average future lifetime in disabled state afld ( 65 , init_state = 0 , trans_probs ) afldF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of indiviudal: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of average future lifetime in disabled state Usage: afldF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS ) Time until onset of Disability: time_to_disabled ( time_to_disabledF ) This function calculates average time for onset of disability, given that the individual becomes disabled. Note that an initial state is not required for this function, as disabled initial state is trivial. time_to_disabled(init_age, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of onset of first diability Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate time until onset of disability time_to_disabled ( 65 , trans_probs ) time_to_disabledF(init_age, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of onset of first disability Usage: time_to_disabledF ( 65 , female = 0 , 2022 , US_HRS ) All Survival Stats: survival_stats ( survival_statsF ) A combination of all the above functions. If transition probabilities are provided, then one simulation is run and all the statistics are calculated from that simulation (this is to keep results consistent). A simulated pathway can also be provided. Time until onset of disability is not returned if initial state is set to 1 as it is trivial. The function returns all the information (mean and variance of each statistic) as a dataframe. survival_stats(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of all statistics Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate all statistics survival_stats ( 65 , init_state = 0 , trans_probs ) survival_statsF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of indiviudal: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of all statistics Usage: survival_statsF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"Statistics"},{"location":"Health/Health%20State%203/stats/#statistics","text":"A lot of mortality statistics can be generated to analyse survival of a certain individual. The following functions return the expected value and variance associated with the lifetime statistic. The functions can use either of the different inputs below to produce the required statistic: list of transition probability matrices from get_trans_probs simulated path matrix from simulate_path If the first option is used, the functions use simulation to find expected value and variance. Hence, there is a stochastic component to these results. If both inputs are provided, then the simulated path wil be used, and no simulation will occur within the function. Each function comes with a frailty version, which has the same name with an 'F' attached to it (eg. afl -> aflF ). The frailty version simulates 'n' unique latent paths, which adds another level of randomness in the statistic. It also requires the same parameters needed to produce a new set of transition probability matrices (see below examples). By default, frailty functions simulate 1000 unique latent factors. For all code examples below, we will use an male individual aged 65 in year 2022.","title":"Statistics"},{"location":"Health/Health%20State%203/stats/#average-future-lifetime-afl-aflf","text":"The function calculates the average future lifetime for a given individual, and its variance. afl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of average future lifetime Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate average future lifetime afl ( 65 , init_state = 0 , trans_probs ) aflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of indiviudal: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of average future lifetime Usage: aflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"Average Future Lifetime: afl (aflF)"},{"location":"Health/Health%20State%203/stats/#healthy-future-lifetime-hfl-hflf","text":"This function calculates the average future lifetime spent in the healthy state, and its variance. hfl(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of healthy future lifetime Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate healthy future lifetime hfl ( 65 , init_state = 0 , trans_probs ) hflF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of indiviudal: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of healthy future lifetime Usage: hflF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"Healthy Future Lifetime hfl (hflF)"},{"location":"Health/Health%20State%203/stats/#average-future-lifetime-in-disabled-state-afld-afldf","text":"This function calculates the average future lifetime spent in the disabled state, and its variance. Not that under the same simulated lifetime, average future lifetime is equal to the sum of healthy lifetime and disabled lifetime. afld(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of average lifetime spent in disabled state Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate average future lifetime in disabled state afld ( 65 , init_state = 0 , trans_probs ) afldF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of indiviudal: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of average future lifetime in disabled state Usage: afldF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"Average Future Lifetime in Disabled State: afld (afldF)"},{"location":"Health/Health%20State%203/stats/#time-until-onset-of-disability-time_to_disabled-time_to_disabledf","text":"This function calculates average time for onset of disability, given that the individual becomes disabled. Note that an initial state is not required for this function, as disabled initial state is trivial. time_to_disabled(init_age, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of onset of first diability Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate time until onset of disability time_to_disabled ( 65 , trans_probs ) time_to_disabledF(init_age, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of onset of first disability Usage: time_to_disabledF ( 65 , female = 0 , 2022 , US_HRS )","title":"Time until onset of Disability: time_to_disabled (time_to_disabledF)"},{"location":"Health/Health%20State%203/stats/#all-survival-stats-survival_stats-survival_statsf","text":"A combination of all the above functions. If transition probabilities are provided, then one simulation is run and all the statistics are calculated from that simulation (this is to keep results consistent). A simulated pathway can also be provided. Time until onset of disability is not returned if initial state is set to 1 as it is trivial. The function returns all the information (mean and variance of each statistic) as a dataframe. survival_stats(init_age, init_state, trans_probs = NULL, simulated_path = NULL) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of individual: 0 for healthy, 1 for disabled trans_probs : list list of transition probability matrices simulated_path : matrix matrix containing life path simulations Returns: Mean and variance of all statistics Usage: # trend model trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , female = 0 , 2022 ) # calculate all statistics survival_stats ( 65 , init_state = 0 , trans_probs ) survival_statsF(init_age, init_state, female, year, param_file, n = 1000) Parameters: init_age : numeric numeric denoting initial age of indiviudal init_state : numeric initial state of indiviudal: 0 for healthy, 1 for disabled female : numeric 0 for male, 1 for female year : numeric numeric denoting current year param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) n : numeric numeric denoting number of unique latent factor simulations Returns: Mean and variance of all statistics Usage: survival_statsF ( 65 , init_state = 0 , female = 0 , 2022 , US_HRS )","title":"All Survival Stats: survival_stats (survival_statsF)"},{"location":"Health/Health%20State%203/trans_probs/","text":"Transition Probability Matrix The Cox Hazard model produces continuous hazard rates, which we discretise by integrating the rates over a year to produce piecewise constant transition rates. This process is repeated for each of the four health state transitions. The transition rates for each age are then put into a transition rate matrix, which can be transformed a transition probabilty matrix by taking the matrix exponential. Note that the transition probability matrices are deterministic for each individual with the Static and Trend models, but stochastic with the Frailty model. Get Transition Probability get_trans_probs(model_type, param_file, init_age, female, year) Parameters: model_type : character 'S' for static model, 'T' for trend, 'F' for frailty param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) init_age : numeric initial age of individual female : numeric 0 indicates male, 1 indicates female year : numeric integer denoting current year Returns: List of transition probability matrices up to and including 110-111, in which everyone dies: \\[\\begin{pmatrix} 0 & 0 & 1 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 1 \\end{pmatrix}\\] The transition probability matrices can then be used to conduct more in depth mortality study. Usage: # list of transition probability matrices under the trend model, # using US_HRS parameters of 65 year old male in 2021 trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , 0 , 2021 )","title":"Transition Probability Matrix"},{"location":"Health/Health%20State%203/trans_probs/#transition-probability-matrix","text":"The Cox Hazard model produces continuous hazard rates, which we discretise by integrating the rates over a year to produce piecewise constant transition rates. This process is repeated for each of the four health state transitions. The transition rates for each age are then put into a transition rate matrix, which can be transformed a transition probabilty matrix by taking the matrix exponential. Note that the transition probability matrices are deterministic for each individual with the Static and Trend models, but stochastic with the Frailty model.","title":"Transition Probability Matrix"},{"location":"Health/Health%20State%203/trans_probs/#get-transition-probability","text":"get_trans_probs(model_type, param_file, init_age, female, year) Parameters: model_type : character 'S' for static model, 'T' for trend, 'F' for frailty param_file : character OR dataframe/tibble File path, or dataframe/tibble of parameters (generally, use US_HRS or china_CLHLS) init_age : numeric initial age of individual female : numeric 0 indicates male, 1 indicates female year : numeric integer denoting current year Returns: List of transition probability matrices up to and including 110-111, in which everyone dies: \\[\\begin{pmatrix} 0 & 0 & 1 \\\\ 0 & 0 & 1 \\\\ 0 & 0 & 1 \\end{pmatrix}\\] The transition probability matrices can then be used to conduct more in depth mortality study. Usage: # list of transition probability matrices under the trend model, # using US_HRS parameters of 65 year old male in 2021 trans_probs <- get_trans_probs ( 'T' , US_HRS , 65 , 0 , 2021 )","title":"Get Transition Probability"},{"location":"Health/Health%20State%205/cox_model/","text":"Cox Hazard Model General Principle The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for an individual \\(k\\) and transition type \\(s\\) is: \\[\\lambda_{k, s}(t)=\\exp \\left\\{\\beta_{s}+\\gamma_{s}^{\\prime} w_{k}(t)+\\alpha_{s} \\psi(t)\\right\\}\\] In the above forumlation, \\(\\beta_{s}\\) is the baseline log-intensity for transition type \\(s\\) , \\(w_{k}(t)\\) contains the age and gender of the individuals, \\(\\gamma_{s}^{\\prime}\\) measure the sensitivity to age and gender, \\(\\psi(t)\\) is a latent process that captures the uncertainty, and \\(\\alpha_{s}\\) measures the sensitivity to the latent process. Three Models Static Model \\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k},\\] where \\(x_k(t)\\) represents the age for the \\(k\\) th individual at time t and \\(F_k = 1\\) if the \\(k\\) th individual is female. The coefficients are parameters to be estimated. Trend Model \\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i,\\] where \\(i\\) is the index number of the interview indicating the time trend. Note that \\(i=1\\) corresponds to the interview year 1998, and the interview is taken every two years. Therefore, i=(interview year - 1998)/2 + 1. Frailty Model \\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i+\\alpha_{s} \\psi_{i},\\] where \\(\\psi_{i}\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi_{i} = \\psi_{i-1} + \\epsilon_{i}\\) with \\(\\epsilon_{i} \\sim \\text{N}(0, 1)\\) . Parameters The module uses cox hazard model parameters estimated from external research studies. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty The estimated parameters of the static, trend, and frailty models from the above study with the US HRS data are embedded in the module. Static model (parameter name: params_5_static) Trend model (parameter name: params_5_trend) Frailty model (parameter name: params_5_frailty) The parameters for each model are constructed as a matrix. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), and \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types.","title":"Cox Hazard Model"},{"location":"Health/Health%20State%205/cox_model/#cox-hazard-model","text":"","title":"Cox Hazard Model"},{"location":"Health/Health%20State%205/cox_model/#general-principle","text":"The Cox Proportional Hazards Model is used to estimate the hazard rate or transition intensity for different transitions. The general form of the transition intensities for an individual \\(k\\) and transition type \\(s\\) is: \\[\\lambda_{k, s}(t)=\\exp \\left\\{\\beta_{s}+\\gamma_{s}^{\\prime} w_{k}(t)+\\alpha_{s} \\psi(t)\\right\\}\\] In the above forumlation, \\(\\beta_{s}\\) is the baseline log-intensity for transition type \\(s\\) , \\(w_{k}(t)\\) contains the age and gender of the individuals, \\(\\gamma_{s}^{\\prime}\\) measure the sensitivity to age and gender, \\(\\psi(t)\\) is a latent process that captures the uncertainty, and \\(\\alpha_{s}\\) measures the sensitivity to the latent process.","title":"General Principle"},{"location":"Health/Health%20State%205/cox_model/#three-models","text":"","title":"Three Models"},{"location":"Health/Health%20State%205/cox_model/#static-model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k},\\] where \\(x_k(t)\\) represents the age for the \\(k\\) th individual at time t and \\(F_k = 1\\) if the \\(k\\) th individual is female. The coefficients are parameters to be estimated.","title":"Static Model"},{"location":"Health/Health%20State%205/cox_model/#trend-model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i,\\] where \\(i\\) is the index number of the interview indicating the time trend. Note that \\(i=1\\) corresponds to the interview year 1998, and the interview is taken every two years. Therefore, i=(interview year - 1998)/2 + 1.","title":"Trend Model"},{"location":"Health/Health%20State%205/cox_model/#frailty-model","text":"\\[\\ln \\left\\{\\lambda_{k, s}(t)\\right\\}=\\beta_{s}+\\gamma_{s}^{\\text{age}} x_{k}(t)+\\gamma_{s}^{\\text {female}} F_{k}+\\phi_{s} i+\\alpha_{s} \\psi_{i},\\] where \\(\\psi_{i}\\) captures the stochastic latent factor. In our model, we use a random walk: \\(\\psi_{i} = \\psi_{i-1} + \\epsilon_{i}\\) with \\(\\epsilon_{i} \\sim \\text{N}(0, 1)\\) .","title":"Frailty Model"},{"location":"Health/Health%20State%205/cox_model/#parameters","text":"The module uses cox hazard model parameters estimated from external research studies. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty The estimated parameters of the static, trend, and frailty models from the above study with the US HRS data are embedded in the module. Static model (parameter name: params_5_static) Trend model (parameter name: params_5_trend) Frailty model (parameter name: params_5_frailty) The parameters for each model are constructed as a matrix. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), and \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types.","title":"Parameters"},{"location":"Health/Health%20State%205/lifetable/","text":"Life Table Generation An individual's characteristics can also be used to generate a life table with a cohort of identical traits. This can be used to calculate the probability of survival to different states. Life tables generated from the static and trend models are always deterministic, so the output will be one lifetable. Meanwhile, the frailty model will produce stochastic ouputs. The lifetables outputted will be a full list of the simulated lifetables. The lifetable shows the number of people in each state at each age, and one can also choose the initial state and the initial age that the starting cohort is in. Generating a Life Table simulate_life_table_5(params,init_age,gender,i,latent,initial_state,n_sim=100, model) Parameters: params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. gender : numeric 0 for male, 1 for female i : numeric interview is taken every two years wave index = (interview year - 1998)/2 + 1 latent : numeric initial value of the latent factor, normally take the value 0 n_sim : numeric integer denoting number of life table simulations model : numeric 1 for static model, 2 for trend model, and 3 for frailty model init_state : numeric integer denoting the current state of individual, 0 for H state, 1 for M state, 2 for D state, 3 for MD state init_age : numeric integer denoting the initial age of life table Returns: a list of life table matrices Usage: # for male aged 65 at wave index i, initially in the health state, using the frailty model with parameters 'params' life_table <- simulate_life_table_5 ( params = params_5_frailty , init_age = 65 , gender = 0 , i = 8 , latent = 0 , initial_state = 0 , n_sim = 100 , model = 3 ) When using static and trend model, 'n_sim' should be set to 1 to avoid generating the same life table repeatedly.","title":"Life Table Generation"},{"location":"Health/Health%20State%205/lifetable/#life-table-generation","text":"An individual's characteristics can also be used to generate a life table with a cohort of identical traits. This can be used to calculate the probability of survival to different states. Life tables generated from the static and trend models are always deterministic, so the output will be one lifetable. Meanwhile, the frailty model will produce stochastic ouputs. The lifetables outputted will be a full list of the simulated lifetables. The lifetable shows the number of people in each state at each age, and one can also choose the initial state and the initial age that the starting cohort is in.","title":"Life Table Generation"},{"location":"Health/Health%20State%205/lifetable/#generating-a-life-table","text":"simulate_life_table_5(params,init_age,gender,i,latent,initial_state,n_sim=100, model) Parameters: params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. gender : numeric 0 for male, 1 for female i : numeric interview is taken every two years wave index = (interview year - 1998)/2 + 1 latent : numeric initial value of the latent factor, normally take the value 0 n_sim : numeric integer denoting number of life table simulations model : numeric 1 for static model, 2 for trend model, and 3 for frailty model init_state : numeric integer denoting the current state of individual, 0 for H state, 1 for M state, 2 for D state, 3 for MD state init_age : numeric integer denoting the initial age of life table Returns: a list of life table matrices Usage: # for male aged 65 at wave index i, initially in the health state, using the frailty model with parameters 'params' life_table <- simulate_life_table_5 ( params = params_5_frailty , init_age = 65 , gender = 0 , i = 8 , latent = 0 , initial_state = 0 , n_sim = 100 , model = 3 ) When using static and trend model, 'n_sim' should be set to 1 to avoid generating the same life table repeatedly.","title":"Generating a Life Table"},{"location":"Health/Health%20State%205/overview/","text":"Overview: 5-State This module conducts mortality analysis using the 5 state model with the following transitions: The five states are: H: Healthy and not functionally disabled D: Healthy and functionally disabled M: Ill health and not functionally disabled MD: Ill health and functionally disabled Dead Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty The transition types are numbered from 1 to 12 illustrated in the table below. Functionalities of the module includes: Calculating transition probability matrices from parameters of Cox Regression model Creating life tables for a certain individual characteristic Simulating lifetime paths Returning key survival statistics for a certain individual These functions can be helpful in conducting mortality studies, as well as applications in insurance pricing.","title":"Overview: 5-State"},{"location":"Health/Health%20State%205/overview/#overview-5-state","text":"This module conducts mortality analysis using the 5 state model with the following transitions: The five states are: H: Healthy and not functionally disabled D: Healthy and functionally disabled M: Ill health and not functionally disabled MD: Ill health and functionally disabled Dead Some studies have already been conducted on this model using fitted Cox Regression models. This module applies the parameters estimated from these studies to analyse the survival statistics of a given individual. The paper that this module refers to is available at: https://www.cepar.edu.au/publications/working-papers/multi-state-model-functional-disability-and-health-status-presence-systematic-trend-and-uncertainty The transition types are numbered from 1 to 12 illustrated in the table below. Functionalities of the module includes: Calculating transition probability matrices from parameters of Cox Regression model Creating life tables for a certain individual characteristic Simulating lifetime paths Returning key survival statistics for a certain individual These functions can be helpful in conducting mortality studies, as well as applications in insurance pricing.","title":"Overview: 5-State"},{"location":"Health/Health%20State%205/simulation/","text":"Simulating Life Paths Expected values are easily derived from the transition probabilities, but some form of simulation is required to analyse variance of risks. Simulation can be performed by using the transition probability matrices. Everyone starts in a certain health state, and we sample movements according to the probabilities given at each age. Death state, -1, is absorbing. The other states are: 0: healthy 1: ill health but not functionally disabled 2: good health but functionally disabled 3: ill health and functionally disabled Simulating State Paths for Individuals simulate_individual_path_5(init_age, init_state, params, gender, i, cohort = 10000, model) Parameters: init_age : numeric integer denoting initial age of individual init_state : numeric integer denoting initial state (see above) params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. gender : numeric 0 for male, 1 for female i : numeric wave index = (interview year - 1998)/2 + 1 cohort : numeric integer denoting number of lives to simulate model : numeric 1 for static, 2 for trend, 3 for frailty Returns: matrix (see below for details) Usage: # simulation for 10000 males aged 65, initially healthy under the frailty model simulated_path <- simulate_individual_path_5 ( init_age = 65 , init_state = 0 , params = params_5_frailty , gender = 0 , i = 8 , cohort = 10000 , model = 3 ) The output is a matrix where each row represents one individual's transition into different states at each year of their life. An example looks like: \\[\\begin{bmatrix} 0 & 0 & 1 & 1 & \\ldots & -1\\\\ 0 & 0 & 2 & 2 & \\ldots & 3 \\\\ & & \\vdots & & & \\\\ 0 & -1 & -1 & -1 & \\ldots & -1 \\\\ 0 & 0 & 3 & 2 & \\ldots & 2 \\end{bmatrix}\\] Note The first column of the matrix will always be initial state provided in the parameters.","title":"Simulating Life Paths"},{"location":"Health/Health%20State%205/simulation/#simulating-life-paths","text":"Expected values are easily derived from the transition probabilities, but some form of simulation is required to analyse variance of risks. Simulation can be performed by using the transition probability matrices. Everyone starts in a certain health state, and we sample movements according to the probabilities given at each age. Death state, -1, is absorbing. The other states are: 0: healthy 1: ill health but not functionally disabled 2: good health but functionally disabled 3: ill health and functionally disabled","title":"Simulating Life Paths"},{"location":"Health/Health%20State%205/simulation/#simulating-state-paths-for-individuals","text":"simulate_individual_path_5(init_age, init_state, params, gender, i, cohort = 10000, model) Parameters: init_age : numeric integer denoting initial age of individual init_state : numeric integer denoting initial state (see above) params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. gender : numeric 0 for male, 1 for female i : numeric wave index = (interview year - 1998)/2 + 1 cohort : numeric integer denoting number of lives to simulate model : numeric 1 for static, 2 for trend, 3 for frailty Returns: matrix (see below for details) Usage: # simulation for 10000 males aged 65, initially healthy under the frailty model simulated_path <- simulate_individual_path_5 ( init_age = 65 , init_state = 0 , params = params_5_frailty , gender = 0 , i = 8 , cohort = 10000 , model = 3 ) The output is a matrix where each row represents one individual's transition into different states at each year of their life. An example looks like: \\[\\begin{bmatrix} 0 & 0 & 1 & 1 & \\ldots & -1\\\\ 0 & 0 & 2 & 2 & \\ldots & 3 \\\\ & & \\vdots & & & \\\\ 0 & -1 & -1 & -1 & \\ldots & -1 \\\\ 0 & 0 & 3 & 2 & \\ldots & 2 \\end{bmatrix}\\] Note The first column of the matrix will always be initial state provided in the parameters.","title":"Simulating State Paths for Individuals"},{"location":"Health/Health%20State%205/stats/","text":"Statistics With the use of simulated paths, a lot of mortality statistics can be generated to analyse or simply gain insight into the survival characteristics of certain individuals. For the 5 state model, we use the simulated paths as inputs to calculate: the average time of entering a certain state (such as the D state: Healthy and functionally disabled) the total time spent in each state As results are stochastic (statistics are derived from random simulated lifetimes), we can also study the variance of these statistics. This will be beneficial in quantifying the risk, allowing for more robust pricing methods. Average First Time Entering State first_time_stats_5(simulated_path, state) Paramters: simulated_path : matrix matrix containing life time simulations, obtained from function \"simulate_individual_path_5\" state : numeric integer denoting which state we are entering or leaving 0 for first time leaving H state, only used when initial state is 0 1 for first time entering M state 2 for first time entering D state 3 for first time entering MD state -1 for first time entering the dead state Returns: column vector of first time entering the specified state Usage: # simulation of 10000 males aged 65 initially healthy under the trend model simulated_path <- simulate_individual_path_5 ( init_age = 65 , init_state = 0 , params = params_5_trend , gender = 0 , i = 8 , cohort = 10000 , model = 2 ) # time until entering M state, ill health but not functionally disabled time_to_M <- first_time_stats_5 ( simulated_path , 1 ) # average initial time of entering state 1 print ( mean ( time_to_M , na.rm = TRUE )) Total Time Spent in State total_time_stats_5(simulated_path, state) Paramters: simulated_path : matrix matrix containing life time simulations, obtained from function \"simulate_individual_path_5\" state : numeric integer denoting which state we are counting 0 for total time in H state 1 for total time in M state 2 for total time in D state 3 for total time in MD state -1 for total time in dead state 4 for total time alive or not in dead state Returns: column vector of total times spent in specified state Usage: # simulation of 10000 males aged 65 initially healthy under the trend model simulated_path <- simulate_individual_path_5 ( init_age = 65 , init_state = 0 , params = params_5_trend , gender = 0 , i = 8 , cohort = 10000 , model = 2 ) # total time spent in MD state, ill health and functionally disabled total_state_MD <- total_time_stats_5 ( simulated_path , 3 ) # average time spent in state MD print ( mean ( total_state_MD )) Produce Mean and Variance from Output This function is a 'helper' function, used in conjunction with the ouput of the previous functions to create the mean and variance of those statistics. stats_produce_5(input) Parameters: input : matrix n \\(\\times\\) 1 matrix of statistics Returns mean and variance of the statistics inputted Usage: # simulation of 10000 males aged 65 initially healthy under the trend model simulated_path <- simulate_individual_path_5 ( init_age = 65 , init_state = 0 , params = params_5_trend , gender = 0 , i = 8 , cohort = 10000 , model = 2 ) # time until entering M state, ill health but not functionally disabled time_to_M <- first_time_stats_5 ( simulated_path , 1 ) # total time spent in MD state, ill health and functionally disabled total_state_MD <- total_time_stats_5 ( simulated_path , 3 ) # produce mean and variance of first time into M state first_time_M_stats <- stats_produce_5 ( time_to_M ) # produce mean and variance of time spent in MD state time_in_MD_stats <- stats_produce_5 ( total_state_MD )","title":"Statistics"},{"location":"Health/Health%20State%205/stats/#statistics","text":"With the use of simulated paths, a lot of mortality statistics can be generated to analyse or simply gain insight into the survival characteristics of certain individuals. For the 5 state model, we use the simulated paths as inputs to calculate: the average time of entering a certain state (such as the D state: Healthy and functionally disabled) the total time spent in each state As results are stochastic (statistics are derived from random simulated lifetimes), we can also study the variance of these statistics. This will be beneficial in quantifying the risk, allowing for more robust pricing methods.","title":"Statistics"},{"location":"Health/Health%20State%205/stats/#average-first-time-entering-state","text":"first_time_stats_5(simulated_path, state) Paramters: simulated_path : matrix matrix containing life time simulations, obtained from function \"simulate_individual_path_5\" state : numeric integer denoting which state we are entering or leaving 0 for first time leaving H state, only used when initial state is 0 1 for first time entering M state 2 for first time entering D state 3 for first time entering MD state -1 for first time entering the dead state Returns: column vector of first time entering the specified state Usage: # simulation of 10000 males aged 65 initially healthy under the trend model simulated_path <- simulate_individual_path_5 ( init_age = 65 , init_state = 0 , params = params_5_trend , gender = 0 , i = 8 , cohort = 10000 , model = 2 ) # time until entering M state, ill health but not functionally disabled time_to_M <- first_time_stats_5 ( simulated_path , 1 ) # average initial time of entering state 1 print ( mean ( time_to_M , na.rm = TRUE ))","title":"Average First Time Entering State"},{"location":"Health/Health%20State%205/stats/#total-time-spent-in-state","text":"total_time_stats_5(simulated_path, state) Paramters: simulated_path : matrix matrix containing life time simulations, obtained from function \"simulate_individual_path_5\" state : numeric integer denoting which state we are counting 0 for total time in H state 1 for total time in M state 2 for total time in D state 3 for total time in MD state -1 for total time in dead state 4 for total time alive or not in dead state Returns: column vector of total times spent in specified state Usage: # simulation of 10000 males aged 65 initially healthy under the trend model simulated_path <- simulate_individual_path_5 ( init_age = 65 , init_state = 0 , params = params_5_trend , gender = 0 , i = 8 , cohort = 10000 , model = 2 ) # total time spent in MD state, ill health and functionally disabled total_state_MD <- total_time_stats_5 ( simulated_path , 3 ) # average time spent in state MD print ( mean ( total_state_MD ))","title":"Total Time Spent in State"},{"location":"Health/Health%20State%205/stats/#produce-mean-and-variance-from-output","text":"This function is a 'helper' function, used in conjunction with the ouput of the previous functions to create the mean and variance of those statistics. stats_produce_5(input) Parameters: input : matrix n \\(\\times\\) 1 matrix of statistics Returns mean and variance of the statistics inputted Usage: # simulation of 10000 males aged 65 initially healthy under the trend model simulated_path <- simulate_individual_path_5 ( init_age = 65 , init_state = 0 , params = params_5_trend , gender = 0 , i = 8 , cohort = 10000 , model = 2 ) # time until entering M state, ill health but not functionally disabled time_to_M <- first_time_stats_5 ( simulated_path , 1 ) # total time spent in MD state, ill health and functionally disabled total_state_MD <- total_time_stats_5 ( simulated_path , 3 ) # produce mean and variance of first time into M state first_time_M_stats <- stats_produce_5 ( time_to_M ) # produce mean and variance of time spent in MD state time_in_MD_stats <- stats_produce_5 ( total_state_MD )","title":"Produce Mean and Variance from Output"},{"location":"Health/Health%20State%205/trans_probs/","text":"Transition Probability Matrix The Cox Hazard model produces continuous hazard rates that will be discretized to produce piecewise constant rates. The process is repeated for each of the 12 transition rates. The rates at each age are combined into transition rate matrices for that age. Taking the matrix exponential changes that to transition probability matrices. Note The transition probability matrices are deterministic for each individual with the Static and Trend models, but stochastic with the Frailty model. Get Transition Rates at a Certain Age transition_rate_5(params,age,gender,i,latent,model) Parameters params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. age : numeric integer denoting the age gender : numeric 0 for male, 1 for female i : numeric integer for the wave index = (interview year - 1998)/2 + 1 latent : numeric initial value of the latent factor, normally take the value 0 model : numeric 1 for static, 2 for trend, 3 for frailty Returns: 5 by 5 matrix containing the transition probabilities between states at the input age, the states are H, M, D, MD, Dead for columns and rows. Usage: # for male aged 65 at wave index i, using the frailty model with parameters 'param' transition_rates = transition_rate_5 ( params = params_5_frailty , age = 65 , gender = 0 , i = 8 , latent = 0 , model = 3 ) Get a Transition Probability Matrix at a Certain Age transition_probability_5(params,age,gender,i,latent,model) Parameters params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. age : numeric integer denoting the age gender : numeric 0 for male, 1 for female i : numeric integer for the wave index = (interview year - 1998)/2 + 1 latent : numeric initial value of the latent factor, normally take the value 0 model : numeric 1 for static, 2 for trend, 3 for frailty Returns: 12 by 1 vector containing the transition rates for transition types 1 to 12 at the input age Usage: # for male aged 65 at wave index i, using the frailty model with parameters 'param' transition_probabilities = transition_probability_5 ( params = params_5_frailty , age = 65 , gender = 0 , i = 8 , latent = 0 , model = 3 ) Get Full List of Transition Probability Matrices from Initial Age to Age 110 get_full_trans_prob_matrix_5(params, init_age, gender, i, model) Parameters params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. init_age : numeric integer denoting the initial age gender : numeric 0 for male, 1 for female i : numeric integer for the wave index wave index = (interview year - 1998)/2 + 1 model : numeric 1 for static, 2 for trend, 3 for frailty Returns: List of 5x5 transition probability matrices, from the initial age to age 110. Usage: # for male aged 65 at wave index i, using the frailty model with parameters 'param' full_trans_probs_matrics <- get_full_trans_prob_matrix_5 ( params = params_5_frailty , init_age = 65 , gender = 0 , i = 8 , model = 3 )","title":"Transition Probability Matrix"},{"location":"Health/Health%20State%205/trans_probs/#transition-probability-matrix","text":"The Cox Hazard model produces continuous hazard rates that will be discretized to produce piecewise constant rates. The process is repeated for each of the 12 transition rates. The rates at each age are combined into transition rate matrices for that age. Taking the matrix exponential changes that to transition probability matrices. Note The transition probability matrices are deterministic for each individual with the Static and Trend models, but stochastic with the Frailty model.","title":"Transition Probability Matrix"},{"location":"Health/Health%20State%205/trans_probs/#get-transition-rates-at-a-certain-age","text":"transition_rate_5(params,age,gender,i,latent,model) Parameters params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. age : numeric integer denoting the age gender : numeric 0 for male, 1 for female i : numeric integer for the wave index = (interview year - 1998)/2 + 1 latent : numeric initial value of the latent factor, normally take the value 0 model : numeric 1 for static, 2 for trend, 3 for frailty Returns: 5 by 5 matrix containing the transition probabilities between states at the input age, the states are H, M, D, MD, Dead for columns and rows. Usage: # for male aged 65 at wave index i, using the frailty model with parameters 'param' transition_rates = transition_rate_5 ( params = params_5_frailty , age = 65 , gender = 0 , i = 8 , latent = 0 , model = 3 )","title":"Get Transition Rates at a Certain Age"},{"location":"Health/Health%20State%205/trans_probs/#get-a-transition-probability-matrix-at-a-certain-age","text":"transition_probability_5(params,age,gender,i,latent,model) Parameters params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. age : numeric integer denoting the age gender : numeric 0 for male, 1 for female i : numeric integer for the wave index = (interview year - 1998)/2 + 1 latent : numeric initial value of the latent factor, normally take the value 0 model : numeric 1 for static, 2 for trend, 3 for frailty Returns: 12 by 1 vector containing the transition rates for transition types 1 to 12 at the input age Usage: # for male aged 65 at wave index i, using the frailty model with parameters 'param' transition_probabilities = transition_probability_5 ( params = params_5_frailty , age = 65 , gender = 0 , i = 8 , latent = 0 , model = 3 )","title":"Get a Transition Probability Matrix at a Certain Age"},{"location":"Health/Health%20State%205/trans_probs/#get-full-list-of-transition-probability-matrices-from-initial-age-to-age-110","text":"get_full_trans_prob_matrix_5(params, init_age, gender, i, model) Parameters params : dataframe Matrix of estimated parameters to construct the five state model. The rows are \\(\\beta\\) , \\(\\gamma^{\\text{age}}\\) , \\(\\gamma^{\\text{f}}\\) , \\(\\phi\\) (if trend or frailty model), \\(\\alpha\\) (if frailty model). The columns are 1-12 transition types. init_age : numeric integer denoting the initial age gender : numeric 0 for male, 1 for female i : numeric integer for the wave index wave index = (interview year - 1998)/2 + 1 model : numeric 1 for static, 2 for trend, 3 for frailty Returns: List of 5x5 transition probability matrices, from the initial age to age 110. Usage: # for male aged 65 at wave index i, using the frailty model with parameters 'param' full_trans_probs_matrics <- get_full_trans_prob_matrix_5 ( params = params_5_frailty , init_age = 65 , gender = 0 , i = 8 , model = 3 )","title":"Get Full List of Transition Probability Matrices from Initial Age to Age 110"},{"location":"Home/about/","text":"About For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"About"},{"location":"Home/about/#about","text":"For full documentation visit mkdocs.org .","title":"About"},{"location":"Home/about/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Home/about/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Home/log/","text":"Changelog","title":"Changelog"},{"location":"Home/log/#changelog","text":"","title":"Changelog"},{"location":"Home/start/","text":"Getting Started Installation Clone repository or download ZIP In RStudio: File > Open project > /rit-main In RStudio Console: install.packages(\"devtools\") library(\"devtools\") load_all(export_all = FALSE) Demo Visit demo/ directory to find example workflows for each module.","title":"Getting Started"},{"location":"Home/start/#getting-started","text":"","title":"Getting Started"},{"location":"Home/start/#installation","text":"Clone repository or download ZIP In RStudio: File > Open project > /rit-main In RStudio Console: install.packages(\"devtools\") library(\"devtools\") load_all(export_all = FALSE)","title":"Installation"},{"location":"Home/start/#demo","text":"Visit demo/ directory to find example workflows for each module.","title":"Demo"},{"location":"Policy%20Valuation/cashflow/","text":"Simulating Cashflows Simulate cash flows using Monte-Carlo methods for a given policy. Function will use generated mortality, health state and economic variables to generate cashflows for n different pathways. This can be used either directly for calculations, or passed into the value_policy function for pricing statistics. simulate_cf(policy, age, sex, seed, n) Parameters: policy : Policy object Policy object generated from create_policy function (see Creating Policy Object ) age : numeric Initial age of policyholder in years sex : character sex = \"F\" (female), \"M\" (male) seed : numeric Random seed used for RNG n : numeric Number of paths to simulate (Monte-Carlo method) state : matrix (Optional) Matrix of health states for n pathways (see Health State / Aggregate Mortality ) econ_var : list (Optional) Simulated economic variables (see Economic Scenario Generator ) Returns: SimCashflow object Usage: ap <- create_policy_AP ( 400000 , 60000 ) cf <- simulate_cf ( policy = ap , age = 65 , sex = \"M\" , n = 1000 ) SimCashflow Attributes: cf : Matrix Simulated cashflows SDF : Matrix Simulated stochastic discount factors","title":"Simulating Cashflows"},{"location":"Policy%20Valuation/cashflow/#simulating-cashflows","text":"Simulate cash flows using Monte-Carlo methods for a given policy. Function will use generated mortality, health state and economic variables to generate cashflows for n different pathways. This can be used either directly for calculations, or passed into the value_policy function for pricing statistics. simulate_cf(policy, age, sex, seed, n) Parameters: policy : Policy object Policy object generated from create_policy function (see Creating Policy Object ) age : numeric Initial age of policyholder in years sex : character sex = \"F\" (female), \"M\" (male) seed : numeric Random seed used for RNG n : numeric Number of paths to simulate (Monte-Carlo method) state : matrix (Optional) Matrix of health states for n pathways (see Health State / Aggregate Mortality ) econ_var : list (Optional) Simulated economic variables (see Economic Scenario Generator ) Returns: SimCashflow object Usage: ap <- create_policy_AP ( 400000 , 60000 ) cf <- simulate_cf ( policy = ap , age = 65 , sex = \"M\" , n = 1000 ) SimCashflow Attributes: cf : Matrix Simulated cashflows SDF : Matrix Simulated stochastic discount factors","title":"Simulating Cashflows"},{"location":"Policy%20Valuation/overview/","text":"Overview This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products. Retirement products include: Account-based pensions Life annuities Deferred life annuities Pooled annuities Long-term care insurance Care annuities Variable annuities with GMWB Reverse mortgages with NNEG Risk-adjusted expected cash flows are computed, and prices are determined based on relevant assumptions. Models use Australian data for Australian applications. The module includes government age pension and aged care based on current means-testing.","title":"Overview"},{"location":"Policy%20Valuation/overview/#overview","text":"This module takes input aggregate mortality scenarios, functional disability/health status scenarios, economic scenarios to simulate cash flows on retirement products. Retirement products include: Account-based pensions Life annuities Deferred life annuities Pooled annuities Long-term care insurance Care annuities Variable annuities with GMWB Reverse mortgages with NNEG Risk-adjusted expected cash flows are computed, and prices are determined based on relevant assumptions. Models use Australian data for Australian applications. The module includes government age pension and aged care based on current means-testing.","title":"Overview"},{"location":"Policy%20Valuation/policy/","text":"Creating Policy Object To begin, we need to initialise a policy object which contains all relevant parameters describing the policy. Functions create_policy_AP - Account Based Pension create_policy_RM - Reverse Mortgage create_policy_LA - Life Annuity create_policy_PA - Pooled Annuity create_policy_CA - Care Annuity (LTC) create_policy_VA - Variable Annuity (GMWB) Account Based Pension create_policy_AP(balance, expenses) Parameters: balance : numeric Initial balance of Pension account expenses : numeric Initial yearly expenses for policyholder Returns: Policy object Usage: ap <- create_policy_AP ( 400000 , 60000 ) Reverse Mortgage (NNEG) create_policy_RM(value, LVR, trans_cost, margin) Parameters: value : numeric Initial value of property LVR : numeric Loan to Value ratio for PH trans_cost : numeric Transaction cost associated with sale margin : numeric Lending margin Returns: Policy object Usage: rm <- create_policy_RM ( 100000 , 0.4 , 0.01 , 0.05 ) Life Annuity create_policy_LA(benefit, defer = 0, increase = 0, loading) Parameters: benefit : numeric Annual benefit for policy defer : numeric (Optional) Deferment period of policy increase : numeric (Optional) Annual rate of increase for policy loading : numeric Loading factor for contract Returns: Policy object Usage: la <- create_policy_LA ( 60000 , 5 , 0.04 , 0.05 ) Care Annuity (LTC) Note: Care annuities are evaluated based on the 3-State or 5-State model outlined in the Health State module . Parameters should be vectors of length 2 or 4 (no benefits paid whilst PH is dead, policies are characterized by remaining states). create_policy_CA(benefit, increase, min, loading) Parameters: benefit : vector Annual benefit for each policy increase : vector Annual rate of increase for each policy min : vector Minimum guaranteed period for each policy loading : vector Loading factor for each policy Returns: Policy object Usage: ca <- create_policy_CA ( c ( 60000 , 1200 ), c ( 0 , 0.04 ), c ( 8 , 0 ), c ( 0.04 , 0.05 )) Pooled Annuity create_policy_PA(benefit, size, interest, loading) Parameters: balance : numeric Initial annual benefit for policy size : numeric Size of pool interest : numeric Assumed investment earnings rate (flat) loading : numeric Loading factor for contract Returns: Policy object Usage: pa <- create_policy_PA ( 60000 , 1000 , 0.04 , 0.05 ) Variable Annuity (GMWB) create_policy_VA(value, length, prop, g_fee) Parameters: value : numeric Initial Account value (single upfront premium) length : numeric Length of contract (in years) prop : numeric Proportion of the premium that can be withdrawn annually g_fee : numeric Continuous guarantee fees for GMWB Returns: Policy object Usage: va <- create_policy_VA ( 100000 , 40 , 0.4 , 0.02 )","title":"Creating Policy Object"},{"location":"Policy%20Valuation/policy/#creating-policy-object","text":"To begin, we need to initialise a policy object which contains all relevant parameters describing the policy.","title":"Creating Policy Object"},{"location":"Policy%20Valuation/policy/#functions","text":"create_policy_AP - Account Based Pension create_policy_RM - Reverse Mortgage create_policy_LA - Life Annuity create_policy_PA - Pooled Annuity create_policy_CA - Care Annuity (LTC) create_policy_VA - Variable Annuity (GMWB)","title":"Functions"},{"location":"Policy%20Valuation/policy/#account-based-pension","text":"create_policy_AP(balance, expenses) Parameters: balance : numeric Initial balance of Pension account expenses : numeric Initial yearly expenses for policyholder Returns: Policy object Usage: ap <- create_policy_AP ( 400000 , 60000 )","title":"Account Based Pension"},{"location":"Policy%20Valuation/policy/#reverse-mortgage-nneg","text":"create_policy_RM(value, LVR, trans_cost, margin) Parameters: value : numeric Initial value of property LVR : numeric Loan to Value ratio for PH trans_cost : numeric Transaction cost associated with sale margin : numeric Lending margin Returns: Policy object Usage: rm <- create_policy_RM ( 100000 , 0.4 , 0.01 , 0.05 )","title":"Reverse Mortgage (NNEG)"},{"location":"Policy%20Valuation/policy/#life-annuity","text":"create_policy_LA(benefit, defer = 0, increase = 0, loading) Parameters: benefit : numeric Annual benefit for policy defer : numeric (Optional) Deferment period of policy increase : numeric (Optional) Annual rate of increase for policy loading : numeric Loading factor for contract Returns: Policy object Usage: la <- create_policy_LA ( 60000 , 5 , 0.04 , 0.05 )","title":"Life Annuity"},{"location":"Policy%20Valuation/policy/#care-annuity-ltc","text":"Note: Care annuities are evaluated based on the 3-State or 5-State model outlined in the Health State module . Parameters should be vectors of length 2 or 4 (no benefits paid whilst PH is dead, policies are characterized by remaining states). create_policy_CA(benefit, increase, min, loading) Parameters: benefit : vector Annual benefit for each policy increase : vector Annual rate of increase for each policy min : vector Minimum guaranteed period for each policy loading : vector Loading factor for each policy Returns: Policy object Usage: ca <- create_policy_CA ( c ( 60000 , 1200 ), c ( 0 , 0.04 ), c ( 8 , 0 ), c ( 0.04 , 0.05 ))","title":"Care Annuity (LTC)"},{"location":"Policy%20Valuation/policy/#pooled-annuity","text":"create_policy_PA(benefit, size, interest, loading) Parameters: balance : numeric Initial annual benefit for policy size : numeric Size of pool interest : numeric Assumed investment earnings rate (flat) loading : numeric Loading factor for contract Returns: Policy object Usage: pa <- create_policy_PA ( 60000 , 1000 , 0.04 , 0.05 )","title":"Pooled Annuity"},{"location":"Policy%20Valuation/policy/#variable-annuity-gmwb","text":"create_policy_VA(value, length, prop, g_fee) Parameters: value : numeric Initial Account value (single upfront premium) length : numeric Length of contract (in years) prop : numeric Proportion of the premium that can be withdrawn annually g_fee : numeric Continuous guarantee fees for GMWB Returns: Policy object Usage: va <- create_policy_VA ( 100000 , 40 , 0.4 , 0.02 )","title":"Variable Annuity (GMWB)"},{"location":"Policy%20Valuation/pricing/","text":"Pricing / Valuation Conducts valuation of a given policy, providing summary statistics. Generates convergence + distribution plots value_policy(policy, cashflows, seed) Parameters: policy : Policy object Policy object generated from create_policy function (see Creating Policy Object ) cashflows : Matrix Matrix of cashflows generated from simulate_cf function (see Simulating Cashflows ) seed : numeric Random seed used for random sampling Returns: PolStats object Usage: > ap <- create_policy_AP ( 400000 , 60000 ) > cf <- simulate_cf ( policy = ap , age = 65 , sex = \"M\" , n = 1000 ) > v <- value_policy ( ap , cf ) ========= Policy Details ========= Type : Account Based Policy ---------------------------------- Balance : 4e+05 Expense : 60000 ======= Summary Statistics ======= Mean : $ 343 , 583.95 Std Dev : $ 39 , 612.09 ---------------------------------- Minimum : $ 55 , 283.93 Maximum : $ 590 , 965.62 ---------------------------------- P_0.25 : $ 316 , 733.50 P_0.50 : $ 339 , 143.08 P_0.75 : $ 365 , 797.98 P_0.95 : $ 413 , 909.46 P_0.99 : $ 455 , 971.51 ---------------------------------- Skewness : 0.44 Kurtosis : 5.47 ================================== PolStats Attributes: paths : Vector Valuation of individual cashflows by path stats : List Summary statistics of valuation conv : Plot Convergence plot of simulation using random sampling dist : Plot Distribution plot of valuations by path","title":"Pricing / Valuation"},{"location":"Policy%20Valuation/pricing/#pricing-valuation","text":"Conducts valuation of a given policy, providing summary statistics. Generates convergence + distribution plots value_policy(policy, cashflows, seed) Parameters: policy : Policy object Policy object generated from create_policy function (see Creating Policy Object ) cashflows : Matrix Matrix of cashflows generated from simulate_cf function (see Simulating Cashflows ) seed : numeric Random seed used for random sampling Returns: PolStats object Usage: > ap <- create_policy_AP ( 400000 , 60000 ) > cf <- simulate_cf ( policy = ap , age = 65 , sex = \"M\" , n = 1000 ) > v <- value_policy ( ap , cf ) ========= Policy Details ========= Type : Account Based Policy ---------------------------------- Balance : 4e+05 Expense : 60000 ======= Summary Statistics ======= Mean : $ 343 , 583.95 Std Dev : $ 39 , 612.09 ---------------------------------- Minimum : $ 55 , 283.93 Maximum : $ 590 , 965.62 ---------------------------------- P_0.25 : $ 316 , 733.50 P_0.50 : $ 339 , 143.08 P_0.75 : $ 365 , 797.98 P_0.95 : $ 413 , 909.46 P_0.99 : $ 455 , 971.51 ---------------------------------- Skewness : 0.44 Kurtosis : 5.47 ================================== PolStats Attributes: paths : Vector Valuation of individual cashflows by path stats : List Summary statistics of valuation conv : Plot Convergence plot of simulation using random sampling dist : Plot Distribution plot of valuations by path","title":"Pricing / Valuation"},{"location":"Policy%20Valuation/workflow/","text":"Workflow Example # Life Annuity la <- create_policy_LA ( 60000 , 5 , 0.02 , 0.05 ) cf_la <- simulate_cf ( la ) val_la <- value_policy ( la , cf_la ) # Care Annuity ca <- create_policy_CA ( c ( 60000 , 1200 ), c ( 0 , 0.04 ), c ( 8 , 0 ), c ( 0.04 , 0.05 )) cf_ca <- simulate_cf ( ca ) val_ca <- value_policy ( ca , cf_ca ) # !! FOLLOWING PRODUCTS NEED DEBUGGING !! # Account-Based Pension ap <- create_policy_AP ( 2000000 , 50000 ) cf_ap <- simulate_cf ( ap ) val_ap <- value_policy ( ap , cf_ap ) # Pooled Annuity pa <- create_policy_PA ( 60000 , 10000 , 0.05 , 0.05 ) cf_pa <- simulate_cf ( pa ) val_pa <- value_policy ( pa , cf_pa ) # Reverse Mortgage rm <- create_policy_RM ( 100000 , 0.4 , 0.01 , 0.05 ) cf_rm <- simulate_cf ( rm ) val_rm <- value_policy ( rm , cf_rm ) # Variable Annuity (GMWB) va <- create_policy_VA ( 100000 , 30 , 0.1 , 0.005 ) cf_va <- simulate_cf ( va ) val_va <- value_policy ( va , cf_va )","title":"Workflow Example"},{"location":"Policy%20Valuation/workflow/#workflow-example","text":"# Life Annuity la <- create_policy_LA ( 60000 , 5 , 0.02 , 0.05 ) cf_la <- simulate_cf ( la ) val_la <- value_policy ( la , cf_la ) # Care Annuity ca <- create_policy_CA ( c ( 60000 , 1200 ), c ( 0 , 0.04 ), c ( 8 , 0 ), c ( 0.04 , 0.05 )) cf_ca <- simulate_cf ( ca ) val_ca <- value_policy ( ca , cf_ca ) # !! FOLLOWING PRODUCTS NEED DEBUGGING !! # Account-Based Pension ap <- create_policy_AP ( 2000000 , 50000 ) cf_ap <- simulate_cf ( ap ) val_ap <- value_policy ( ap , cf_ap ) # Pooled Annuity pa <- create_policy_PA ( 60000 , 10000 , 0.05 , 0.05 ) cf_pa <- simulate_cf ( pa ) val_pa <- value_policy ( pa , cf_pa ) # Reverse Mortgage rm <- create_policy_RM ( 100000 , 0.4 , 0.01 , 0.05 ) cf_rm <- simulate_cf ( rm ) val_rm <- value_policy ( rm , cf_rm ) # Variable Annuity (GMWB) va <- create_policy_VA ( 100000 , 30 , 0.1 , 0.005 ) cf_va <- simulate_cf ( va ) val_va <- value_policy ( va , cf_va )","title":"Workflow Example"}]}